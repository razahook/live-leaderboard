<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-Stream Viewer</title>
  <style>
    :root {
      color-scheme: dark;
      --color-bg: #0f172a;
      --color-bg-alt: #1e293b;
      --color-border: rgba(148,163,184,.2);
      --color-border-strong: rgba(148,163,184,.35);
      --color-primary-start: #22c55e;
      --color-primary-end: #16a34a;
      --color-accent-start: #8b5cf6;
      --color-accent-end: #7c3aed;
      --color-warning-start: #f59e0b;
      --color-warning-end: #d97706;
      --font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* Reset & base */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-family);
      background: var(--color-bg);
      color: #e5e7eb;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
      padding: 12px;
    }

    .container {
      max-width: 1920px;
      width: 100%;
      background: var(--color-bg-alt);
      border-radius: 16px;
      box-shadow:
        0 4px 12px rgba(0,0,0,0.8),
        inset 0 0 0 1px var(--color-border-strong);
      padding: 20px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .header {
      background: rgba(30, 41, 59, 0.95);
      border-radius: 20px;
      padding: 24px 28px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      border: 1.5px solid var(--color-border);
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #d1d5db;
      user-select: none;
    }

    .header p {
      margin: 0;
      color: #94a3b8;
      font-size: 15px;
      font-weight: 500;
      user-select: none;
    }

         .multistream-clip-controls {
       margin-top: 16px;
       display: flex;
       flex-direction: column;
       gap: 12px;
       width: 100%;
     }

    .btn {
      padding: 12px 20px;
      border-radius: 14px;
      border: none;
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 3px 7px rgba(0,0,0,0.3);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
      color: #f0fdf4;
      box-shadow: 0 5px 15px rgba(34, 197, 94, 0.6);
    }
    .btn-primary:hover {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 6px 18px rgba(22, 163, 74, 0.8);
    }

    .btn-warning {
      background: linear-gradient(135deg, var(--color-warning-start), var(--color-warning-end));
      color: #fff7ed;
      box-shadow: 0 5px 15px rgba(245, 158, 11, 0.6);
    }
    .btn-warning:hover {
      background: linear-gradient(135deg, #d97706, #f59e0b);
      box-shadow: 0 6px 18px rgba(217, 119, 6, 0.8);
    }

    .btn-accent {
      background: linear-gradient(135deg, var(--color-accent-start), var(--color-accent-end));
      color: #ede9fe;
      box-shadow: 0 5px 15px rgba(139, 92, 246, 0.6);
    }
    .btn-accent:hover {
      background: linear-gradient(135deg, #7c3aed, #8b5cf6);
      box-shadow: 0 6px 18px rgba(124, 58, 237, 0.8);
    }

         .multistream-clip-controls button {
       width: 100%;
       min-width: auto;
     }

    .controls {
      margin-top: 18px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .controls input {
      width: 100%;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1.8px solid #334155;
      background: #0b1220;
      color: #e5e7eb;
      font-size: 16px;
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .controls input::placeholder {
      color: #64748b;
      font-weight: 400;
    }
    .controls input:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 10px #8b5cf6aa;
      background: #121a34;
    }

    .controls select {
      width: 100%;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1.8px solid #334155;
      background: #0b1220;
      color: #e5e7eb;
      font-size: 16px;
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      cursor: pointer;
    }
    .controls select:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 10px #8b5cf6aa;
      background: #121a34;
    }
    .controls select option {
      background: #0b1220;
      color: #e5e7eb;
      padding: 8px;
    }
    
    .streamer-dropdown {
      position: relative;
    }
    
    .streamer-dropdown.loading {
      opacity: 0.7;
      pointer-events: none;
    }
    
    .streamer-dropdown.loading::after {
      content: "⏳";
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from { transform: translateY(-50%) rotate(0deg); }
      to { transform: translateY(-50%) rotate(360deg); }
    }

    button[onclick="loadStreams()"] {
      margin-top: 20px;
      width: 100%;
      font-size: 18px;
      padding: 14px 0;
      border-radius: 16px;
      font-weight: 700;
      box-shadow: 0 7px 20px rgba(34, 197, 94, 0.6);
      transition: background-color 0.35s ease, box-shadow 0.35s ease;
    }
    button[onclick="loadStreams()"]:hover {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 10px 28px rgba(22, 163, 74, 0.8);
    }

    .grid {
      margin-top: 24px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 32px;
      width: 100%;
    }

    .tile {
      background: rgba(17, 24, 39, 0.85);
      border-radius: 16px;
      border: 1.5px solid var(--color-border);
      overflow: hidden;
      position: relative;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      user-select: none;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .tile header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
      font-size: 14px;
      font-weight: 600;
      color: #cbd5e1;
      background: rgba(31, 41, 55, 0.75);
      text-transform: capitalize;
    }

    .tile header span {
      flex-grow: 1;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .tile header button {
      background: #334155;
      color: #e5e7eb;
      font-weight: 600;
      font-size: 13px;
      padding: 6px 14px;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
      flex-shrink: 0;
      margin-left: 12px;
    }
    .tile header button:hover {
      background: #475569;
      box-shadow: 0 3px 9px rgba(71,85,105,0.6);
    }

    .tile[data-selected="true"] {
      outline: 3px solid #8b5cf6;
      box-shadow: 0 0 16px 3px #8b5cf6cc;
      border-color: #8b5cf6;
      z-index: 10;
    }
    
    .tile.has-stream {
      border-color: #22c55e;
      box-shadow: 0 6px 18px rgba(34, 197, 94, 0.3);
    }
    
    .tile.has-stream header span {
      color: #22c55e;
      font-weight: 700;
    }

    .player {
      flex-grow: 1;
      background: #000;
      position: relative;
      min-height: 500px;
      border-radius: 0 0 16px 16px;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
      aspect-ratio: 16 / 9;
      background: #000;
      border-radius: 0 0 16px 16px;
      pointer-events: auto;
      min-height: 500px;
    }

    @media (max-width: 1200px) {
      .grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 800px) {
      .grid {
        grid-template-columns: 1fr;
      }
      .controls {
        grid-template-columns: 1fr;
      }
      .multistream-clip-controls {
        flex-direction: column;
      }
      .multistream-clip-controls button {
        width: 100%;
      }
      .header > div:last-child {
        flex-direction: column;
      }
      .header > div:last-child button {
        width: 100%;
      }
    }
  </style>
</head>
<body class="stream-mode">
  <div class="container">
    <div class="header">
      <h1>🎬 Clip Management</h1>
      <p>Create and manage clips for your selected streams</p>
      <div class="multistream-clip-controls">
        <button class="btn btn-primary" onclick="createClipForCurrentStream()">📹 Create Clip</button>
        <button class="btn btn-warning" onclick="openMedalImport()">🏅 Import Medal.tv</button>
        <button class="btn btn-accent" onclick="viewMyClips()">📋 My Clips</button>
      </div>
      <div class="controls">
        <select id="s1" class="streamer-dropdown">
          <option value="">-- Select Streamer 1 --</option>
        </select>
        <select id="s2" class="streamer-dropdown">
          <option value="">-- Select Streamer 2 --</option>
        </select>
        <select id="s3" class="streamer-dropdown">
          <option value="">-- Select Streamer 3 --</option>
        </select>
      </div>
      <div style="display: flex; gap: 12px; margin-top: 20px;">
        <button class="btn btn-primary" onclick="loadStreams()" style="flex: 1;">Load Streams</button>
        <button class="btn btn-accent" onclick="loadSampleStreamers()" style="flex: 0 0 auto;">Load Sample</button>
        <button class="btn btn-warning" onclick="populateStreamerDropdowns()" style="flex: 0 0 auto;">🔄 Refresh Live Streamers</button>
      </div>
    </div>

    <div id="multistream" class="grid" aria-label="Stream tiles">
      <div class="tile" id="tile-1" data-idx="1" tabindex="0" aria-selected="false">
        <header>
          <span>Empty</span>
          <button class="btn" style="background:#334155" onclick="selectTile(1)">Select</button>
        </header>
        <div class="player"></div>
      </div>
      <div class="tile" id="tile-2" data-idx="2" tabindex="0" aria-selected="false">
        <header>
          <span>Empty</span>
          <button class="btn" style="background:#334155" onclick="selectTile(2)">Select</button>
        </header>
        <div class="player"></div>
      </div>
      <div class="tile" id="tile-3" data-idx="3" tabindex="0" aria-selected="false">
        <header>
          <span>Empty</span>
          <button class="btn" style="background:#334155" onclick="selectTile(3)">Select</button>
        </header>
        <div class="player"></div>
      </div>
    </div>
  </div>

  <script src="https://embed.twitch.tv/embed/v1.js"></script>
  <script>
          // Function to populate streamer dropdowns with live streamers
   async function populateStreamerDropdowns() {
     // Define dropdowns outside try block so it's accessible in finally
     const dropdowns = ['s1', 's2', 's3'];
     
     console.log('Starting populateStreamerDropdowns function...');
     console.log('Dropdown IDs:', dropdowns);
     
     try {
       // Show loading state
       dropdowns.forEach(id => {
         const dropdown = document.getElementById(id);
         console.log('Found dropdown:', id, dropdown);
         if (dropdown) {
           dropdown.classList.add('loading');
         }
       });
       
       // First try localStorage cache - check both cache keys used by main page and stream page
      let allPlayers = [];
      const mainPageCache = localStorage.getItem('leaderboard_cache');
      const streamPageCache = localStorage.getItem('leaderboardCache');
      
      if (mainPageCache) {
        try {
          const cache = JSON.parse(mainPageCache);
          if (cache.data && Array.isArray(cache.data)) {
            allPlayers = cache.data;
            console.log('Using main page cached data:', allPlayers.length);
          } else if (cache.data && cache.data.players && Array.isArray(cache.data.players)) {
            allPlayers = cache.data.players;
            console.log('Using main page cached data.players:', allPlayers.length);
          } else {
            console.log('Main page cached data structure not recognized:', cache);
          }
        } catch (e) {
          console.error('Error parsing main page cache:', e);
        }
      }
      
      // If no main page cache, try stream page cache
      if (allPlayers.length === 0 && streamPageCache) {
        try {
          const cache = JSON.parse(streamPageCache);
          if (cache.data && Array.isArray(cache.data)) {
            allPlayers = cache.data;
            console.log('Using stream page cached data:', allPlayers.length);
          } else {
            console.log('Stream page cached data is not an array, will fetch from API');
          }
        } catch (e) {
          console.error('Error parsing stream page cache:', e);
        }
      }
      
      // If no cache, fetch from leaderboard API
      if (allPlayers.length === 0) {
        try {
          console.log('No cached data, fetching from API...');
          const response = await fetch('/api/stats/PC');
          console.log('API response:', response);
          console.log('Response status:', response.status);
          console.log('Response ok:', response.ok);
          
          if (response.ok) {
            const data = await response.json();
            console.log('API response data:', data);
            console.log('data.data type:', typeof data.data);
            console.log('data.data value:', data.data);
            console.log('data.data keys:', data.data ? Object.keys(data.data) : 'null/undefined');
            
            if (data.success && data.data) {
              // The main page shows data.data.players is where the actual player array is
              if (data.data.players && Array.isArray(data.data.players)) {
                allPlayers = data.data.players;
                console.log('Found players array in data.data.players:', allPlayers.length);
              } else if (Array.isArray(data.data)) {
                allPlayers = data.data;
                console.log('data.data is directly an array:', allPlayers.length);
              } else {
                console.log('data.data structure:', data.data);
                console.log('data.data keys:', Object.keys(data.data));
                // Try to find any array in the response
                const findArray = (obj) => {
                  if (Array.isArray(obj)) return obj;
                  if (typeof obj === 'object' && obj !== null) {
                    for (const key in obj) {
                      if (Array.isArray(obj[key])) return obj[key];
                      const result = findArray(obj[key]);
                      if (result) return result;
                    }
                  }
                  return null;
                };
                const foundArray = findArray(data);
                if (foundArray) {
                  allPlayers = foundArray;
                  console.log('Found array in response:', foundArray.length);
                } else {
                  console.log('No array found in response');
                }
              }
              
              console.log('Final allPlayers:', allPlayers);
              console.log('allPlayers length:', allPlayers ? allPlayers.length : 'null/undefined');
             
              if (allPlayers && allPlayers.length > 0) {
                // Store in both cache keys for compatibility
                try {
                  localStorage.setItem('leaderboard_cache', JSON.stringify({
                    data: allPlayers,
                    timestamp: Date.now()
                  }));
                  localStorage.setItem('leaderboardCache', JSON.stringify({
                    data: allPlayers,
                    timestamp: Date.now()
                  }));
                  console.log('Cached data in both locations');
                } catch (e) {
                  console.warn('Failed to cache data:', e);
                }
              }
            } else {
              console.log('API response not successful or no data');
            }
          } else {
            console.error('API response not ok:', response.status, response.statusText);
          }
        } catch (fetchError) {
          console.error('Error fetching leaderboard:', fetchError);
        }
      }
       
       // Ensure allPlayers is always an array before filtering
       if (!Array.isArray(allPlayers)) {
         console.log('allPlayers is not an array, resetting to empty array');
         allPlayers = [];
       }
       
       // Filter for live streamers - same logic as main page
       const liveStreamers = allPlayers.filter(player => {
         const twitchLive = player.twitch_live?.is_live === true;
         const hasUser = !!(player.stream?.twitchUser || player.canonical_twitch_username || player.twitch_link);
         return twitchLive && hasUser;
       });
       
       console.log('Live streamers found:', liveStreamers.length);
       
       // Populate all three dropdowns
       dropdowns.forEach(dropdownId => {
         const dropdown = document.getElementById(dropdownId);
         const placeholder = dropdown.options[0];
         dropdown.innerHTML = '';
         dropdown.appendChild(placeholder);
         
         console.log(`Populating dropdown ${dropdownId} with ${liveStreamers.length} streamers`);
         
         // Add live streamers - same as main page
         liveStreamers.forEach(player => {
           const twitchUsername = player.stream?.twitchUser || player.canonical_twitch_username || (player.twitch_link ? extractUsernameFromLink(player.twitch_link) : null);
           const viewerCount = player.stream?.viewers || 0;
           
           if (twitchUsername) {
             const option = document.createElement('option');
             option.value = twitchUsername;
             option.textContent = `${player.name || player.player_name || twitchUsername} (${viewerCount.toLocaleString()} viewers)`;
             option.dataset.playerName = player.name || player.player_name;
             dropdown.appendChild(option);
             console.log(`Added option: ${twitchUsername} - ${player.name || player.player_name} (${viewerCount} viewers)`);
           }
         });
         
         console.log(`Dropdown ${dropdownId} now has ${dropdown.options.length} options`);
       });
        
        // Add change event listeners to auto-load streams
        dropdowns.forEach(dropdownId => {
          const dropdown = document.getElementById(dropdownId);
          dropdown.onchange = () => {
            console.log(`Dropdown ${dropdownId} changed to:`, dropdown.value);
            // Auto-load streams when selection changes
            setTimeout(() => loadStreams(), 100);
          };
        });
               
       // Show success message
       if (liveStreamers.length > 0) {
         showMessage(`Found ${liveStreamers.length} live streamers!`, 'success');
       } else {
         showMessage('No live streamers found. Try refreshing.', 'info');
       }
        
      } catch (error) {
        console.error('Error populating streamer dropdowns:', error);
        showMessage('Failed to load live streamers.', 'info');
      } finally {
        // Remove loading state
        dropdowns.forEach(id => {
          const dropdown = document.getElementById(id);
          dropdown.classList.remove('loading');
        });
      }
    }
    
    // Helper function to extract username from Twitch link
    function extractUsernameFromLink(link) {
      if (!link) return null;
      const match = link.match(/twitch\.tv\/([a-zA-Z0-9_]+)/);
      return match ? match[1].toLowerCase() : null;
    }
    
    const tiles = [null, document.getElementById('tile-1'), document.getElementById('tile-2'), document.getElementById('tile-3')];
    
    function twitchIframe(channel) {
      // Use the correct parent domain for Twitch embedding
      // On Vercel, we need to use the actual domain, not the git branch subdomain
      let parent = location.hostname;
      
      console.log('Original hostname:', parent);
      console.log('Is Vercel preview?', parent.includes('vercel.app') && parent.includes('git-'));
      
      // If we're on a Vercel preview deployment, use the main domain
      if (parent.includes('vercel.app') && parent.includes('git-')) {
        // For Vercel git branch deployments, use the current preview URL as parent
        // Twitch allows preview URLs as valid parent domains
        console.log('Using preview URL as parent domain:', parent);
        // Keep the original parent (current hostname) for Twitch embed
      }
      
      console.log('Final parent domain for Twitch embed:', parent);
      
      // Create a unique ID for this iframe
      const iframeId = `twitch-iframe-${channel}-${Date.now()}`;
      
      // Return the iframe HTML with the correct parent domain
      return `<iframe id="${iframeId}" allowfullscreen allow="autoplay; fullscreen" src="https://player.twitch.tv/?channel=${encodeURIComponent(channel)}&parent=${encodeURIComponent(parent)}&muted=true"></iframe>`;
    }
    
    function setTile(idx, channel) {
      const tile = tiles[idx];
      const header = tile.querySelector('header span');
      const player = tile.querySelector('.player');
      
      console.log(`setTile called for index: ${idx}, channel: ${channel}`);
      console.log('Tile element:', tile);
      console.log('Header element:', header);
      console.log('Player element:', player);
      
      if (channel && channel.trim()) {
        header.textContent = channel;
        const iframe = twitchIframe(channel);
        console.log('Created iframe HTML:', iframe);
        player.innerHTML = iframe;
        tile.dataset.username = channel;
        tile.classList.add('has-stream');
        console.log('Tile updated with stream:', channel);
        
        // Add error handling for the iframe
        setTimeout(() => {
          const iframeElement = player.querySelector('iframe');
          if (iframeElement) {
            iframeElement.onerror = () => {
              console.error(`Failed to load Twitch iframe for ${channel}`);
            };
            iframeElement.onload = () => {
              console.log(`Twitch iframe loaded successfully for ${channel}`);
            };
          }
        }, 100);
      } else {
        header.textContent = 'Empty';
        player.innerHTML = '';
        tile.dataset.username = '';
        tile.classList.remove('has-stream');
        console.log('Tile cleared');
      }
    }
    
    function loadStreams() {
      const s1 = document.getElementById('s1').value.trim();
      const s2 = document.getElementById('s2').value.trim();
      const s3 = document.getElementById('s3').value.trim();
      
      console.log('loadStreams called with values:', { s1, s2, s3 });
      
      setTile(1, s1);
      setTile(2, s2);
      setTile(3, s3);
      
      // Auto select first non-empty stream
      const first = [1,2,3].find(i => tiles[i].dataset.username);
      console.log('First non-empty stream index:', first);
      if (first) selectTile(first);
      
      // Show success message
      const loadedCount = [s1, s2, s3].filter(s => s.trim()).length;
      console.log('Loaded stream count:', loadedCount);
      if (loadedCount > 0) {
        showMessage(`Loaded ${loadedCount} stream(s) successfully!`, 'success');
      }
    }
    
    function selectTile(idx) {
      console.log('selectTile called with index:', idx);
      tiles.forEach(t => t && t.removeAttribute('data-selected'));
      tiles[idx].setAttribute('data-selected', 'true');
      // For accessibility
      tiles.forEach(t => t && t.setAttribute('aria-selected', 'false'));
      tiles[idx].setAttribute('aria-selected', 'true');
    }
    
    function loadSampleStreamers() {
      console.log('loadSampleStreamers called');
      // Set sample streamers in dropdowns
      const sampleStreamers = ['aceu', 'shroud', 'iitztimmy'];
      
      // Find and select the sample streamers in the dropdowns
      const s1Dropdown = document.getElementById('s1');
      const s2Dropdown = document.getElementById('s2');
      const s3Dropdown = document.getElementById('s3');
      
      // Try to find and select the sample streamers
      const setSampleStreamer = (dropdown, username) => {
        for (let i = 0; i < dropdown.options.length; i++) {
          if (dropdown.options[i].value === username) {
            dropdown.selectedIndex = i;
            return true;
          }
        }
        // If not found, set the value directly
        dropdown.value = username;
        return false;
      };
      
      setSampleStreamer(s1Dropdown, sampleStreamers[0]);
      setSampleStreamer(s2Dropdown, sampleStreamers[1]);
      setSampleStreamer(s3Dropdown, sampleStreamers[2]);
      
      console.log('Sample streamers set, calling loadStreams');
      loadStreams();
    }
    
    function showMessage(message, type = 'info') {
      const existing = document.querySelector('.message');
      if (existing) existing.remove();
      
      const msg = document.createElement('div');
      msg.className = `message message-${type}`;
      msg.textContent = message;
      msg.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        z-index: 1000;
        background: ${type === 'success' ? '#22c55e' : '#3b82f6'};
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      
      document.body.appendChild(msg);
      setTimeout(() => msg.remove(), 3000);
    }
    
    // Helpers used by multistream-clips.js
    window.getCurrentStreamFocus = function () {
      const focused = document.querySelector('[data-selected="true"][data-idx]');
      return focused ? (focused.dataset.username || null) : null;
    }
    
    // Auto-populate dropdowns with live streamers on page load
    document.addEventListener('DOMContentLoaded', function() {
      populateStreamerDropdowns();
    });
  </script>

   <script src="/js/multistream-clips.js?v=stream-1"></script>
 </body>
 </html>


