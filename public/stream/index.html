<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-Stream Viewer - Enhanced</title>
  <style>
    :root {
      color-scheme: dark;
      --color-bg: #0f172a;
      --color-bg-alt: #1e293b;
      --color-border: rgba(148,163,184,.2);
      --color-border-strong: rgba(148,163,184,.35);
      --color-primary-start: #22c55e;
      --color-primary-end: #16a34a;
      --color-accent-start: #8b5cf6;
      --color-accent-end: #7c3aed;
      --color-warning-start: #f59e0b;
      --color-warning-end: #d97706;
      --font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* Reset & base */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-family);
      background: var(--color-bg);
      color: #e5e7eb;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
      padding: 0;
    }

    .container {
      max-width: 100vw;
      width: 100%;
      background: transparent;
      border-radius: 0;
      box-shadow: none;
      padding: clamp(12px, 2vw, 24px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 2vw, 32px);
      min-height: 100vh;
    }

    .header {
      background: rgba(30, 41, 59, 0.95);
      border-radius: 20px;
      padding: 24px 28px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      border: 1.5px solid var(--color-border);
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #d1d5db;
      user-select: none;
    }

    .header p {
      margin: 0;
      color: #94a3b8;
      font-size: 15px;
      font-weight: 500;
      user-select: none;
    }

         .multistream-clip-controls {
       margin-top: 16px;
       display: flex;
       flex-direction: column;
       gap: 12px;
       width: 100%;
     }

    .btn {
      padding: 12px 20px;
      border-radius: 14px;
      border: none;
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 3px 7px rgba(0,0,0,0.3);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
      color: #f0fdf4;
      box-shadow: 0 5px 15px rgba(34, 197, 94, 0.6);
    }
    .btn-primary:hover {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 6px 18px rgba(22, 163, 74, 0.8);
    }

    .btn-warning {
      background: linear-gradient(135deg, var(--color-warning-start), var(--color-warning-end));
      color: #fff7ed;
      box-shadow: 0 5px 15px rgba(245, 158, 11, 0.6);
    }
    .btn-warning:hover {
      background: linear-gradient(135deg, #d97706, #f59e0b);
      box-shadow: 0 6px 18px rgba(217, 119, 6, 0.8);
    }

    .btn-accent {
      background: linear-gradient(135deg, var(--color-accent-start), var(--color-accent-end));
      color: #ede9fe;
      box-shadow: 0 5px 15px rgba(139, 92, 246, 0.6);
    }
    .btn-accent:hover {
      background: linear-gradient(135deg, #7c3aed, #8b5cf6);
      box-shadow: 0 6px 18px rgba(124, 58, 237, 0.8);
    }

         .multistream-clip-controls button {
       width: 100%;
       min-width: auto;
     }

    .controls {
      margin-top: 18px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .controls input {
      width: 100%;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1.8px solid #334155;
      background: #0b1220;
      color: #e5e7eb;
      font-size: 16px;
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .controls input::placeholder {
      color: #64748b;
      font-weight: 400;
    }
    .controls input:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 10px #8b5cf6aa;
      background: #121a34;
    }

    .controls select {
      width: 100%;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1.8px solid #334155;
      background: #0b1220;
      color: #e5e7eb;
      font-size: 16px;
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      cursor: pointer;
    }
    .controls select:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 10px #8b5cf6aa;
      background: #121a34;
    }
    .controls select option {
      background: #0b1220;
      color: #e5e7eb;
      padding: 8px;
    }
    
    .streamer-dropdown {
      position: relative;
    }
    
    .streamer-dropdown.loading {
      opacity: 0.7;
      pointer-events: none;
    }
    
    .streamer-dropdown.loading::after {
      content: "‚è≥";
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from { transform: translateY(-50%) rotate(0deg); }
      to { transform: translateY(-50%) rotate(360deg); }
    }

    #load-streams-btn {
      margin-top: 20px;
      width: 100%;
      font-size: 18px;
      padding: 14px 0;
      border-radius: 16px;
      font-weight: 700;
      box-shadow: 0 7px 20px rgba(34, 197, 94, 0.6);
      transition: background-color 0.35s ease, box-shadow 0.35s ease;
    }
    #load-streams-btn:hover {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 10px 28px rgba(22, 163, 74, 0.8);
    }

    .grid {
      margin-top: 32px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: clamp(32px, 5vw, 80px);
      width: 100%;
      /* Remove fixed height to allow natural aspect ratio */
      align-items: stretch;
      padding: 0 clamp(16px, 3vw, 48px);
    }

    .tile {
      background: rgba(17, 24, 39, 0.85);
      border-radius: 16px;
      border: 1.5px solid var(--color-border);
      overflow: hidden;
      position: relative;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      user-select: none;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .tile header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
      font-size: 14px;
      font-weight: 600;
      color: #cbd5e1;
      background: rgba(31, 41, 55, 0.75);
      text-transform: capitalize;
    }

    .tile header span {
      flex-grow: 1;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .tile header button {
      background: #334155;
      color: #e5e7eb;
      font-weight: 600;
      font-size: 13px;
      padding: 6px 14px;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
      flex-shrink: 0;
      margin-left: 12px;
    }
    .tile header button:hover {
      background: #475569;
      box-shadow: 0 3px 9px rgba(71,85,105,0.6);
    }

    .tile[data-selected="true"] {
      outline: 3px solid #8b5cf6;
      box-shadow: 0 0 16px 3px #8b5cf6cc;
      border-color: #8b5cf6;
      z-index: 10;
    }
    
    .tile.has-stream {
      border-color: #22c55e;
      box-shadow: 0 6px 18px rgba(34, 197, 94, 0.3);
    }
    
    .tile.has-stream header span {
      color: #22c55e;
      font-weight: 700;
    }

    /* StreamManager State Styles */
    .tile.loading {
      background: linear-gradient(45deg, rgba(17, 24, 39, 0.85) 25%, rgba(31, 41, 55, 0.9) 25%, rgba(31, 41, 55, 0.9) 50%, rgba(17, 24, 39, 0.85) 50%, rgba(17, 24, 39, 0.85) 75%, rgba(31, 41, 55, 0.9) 75%);
      background-size: 40px 40px;
      animation: loading-stripe 1.5s linear infinite;
      border-color: #8b5cf6;
    }

    .tile.error {
      background: linear-gradient(135deg, rgba(17, 24, 39, 0.85) 0%, rgba(75, 20, 30, 0.9) 100%);
      border-color: #dc2626;
    }

    .tile.offline {
      background: linear-gradient(135deg, rgba(17, 24, 39, 0.85) 0%, rgba(75, 75, 20, 0.9) 100%);
      border-color: #ca8a04;
    }

    @keyframes loading-stripe {
      0% { background-position: 0 0; }
      100% { background-position: 40px 40px; }
    }

    .stream-status {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(148, 163, 184, 0.3);
      border-top: 4px solid #8b5cf6;
      border-radius: 50%;
      animation: spinner-spin 1s linear infinite;
      margin: 0 auto 12px auto;
    }

    @keyframes spinner-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-message {
      color: #e5e7eb;
      font-size: 14px;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      margin-bottom: 8px;
    }

    .error-message {
      color: #fca5a5;
    }

    .offline-message {
      color: #fcd34d;
    }

    .retry-button {
      background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
      color: #f0fdf4;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      margin-top: 8px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 6px rgba(34, 197, 94, 0.4);
      pointer-events: auto;
    }

    .retry-button:hover {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 3px 8px rgba(22, 163, 74, 0.6);
      transform: translateY(-1px);
    }

    .player {
      /* Use aspect-ratio for perfect 16:9 ratio (1.778) matching official Twitch */
      aspect-ratio: 16 / 9;
      background: #000;
      position: relative;
      border-radius: 0 0 16px 16px;
      width: 100%;
      display: flex;
      align-items: stretch;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
      background: #000;
      border-radius: 0 0 16px 16px;
      pointer-events: auto;
      /* Remove object-fit to allow Twitch player natural scaling */
    }
    
    .twitch-embed-container {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
      border-radius: 0;
      overflow: hidden;
      /* Remove object-fit to allow natural Twitch player scaling */
    }

    @media (max-width: 1200px) {
      .grid {
        grid-template-columns: repeat(2, 1fr);
        gap: clamp(16px, 3vw, 40px);
        /* Remove fixed height to maintain aspect ratio */
      }
    }

    @media (max-width: 800px) {
      .grid {
        grid-template-columns: 1fr;
        /* Remove fixed height to maintain aspect ratio */
      }
      /* Remove min-height constraint to allow natural 16:9 aspect ratio */
      .controls {
        grid-template-columns: 1fr;
      }
      .multistream-clip-controls {
        flex-direction: column;
      }
      .multistream-clip-controls button {
        width: 100%;
      }
      .header > div:last-child {
        flex-direction: column;
      }
      .header > div:last-child button {
        width: 100%;
      }
    }
  </style>
</head>
<body class="stream-mode">
  <div class="container">
    <div class="header">
      <h1>üé¨ Clip Management</h1>
      <p>Create and manage clips for your selected streams</p>
      <div class="multistream-clip-controls">
        <button class="btn btn-primary" onclick="createClipForCurrentStream()">üìπ Create Clip</button>
        <button class="btn btn-warning" onclick="openMedalImport()">üèÖ Import Medal.tv</button>
        <button class="btn btn-accent" onclick="viewMyClips()">üìã My Clips</button>
      </div>
      <div class="controls">
        <select id="s1" class="streamer-dropdown">
          <option value="">-- Select Streamer 1 --</option>
        </select>
        <select id="s2" class="streamer-dropdown">
          <option value="">-- Select Streamer 2 --</option>
        </select>
        <select id="s3" class="streamer-dropdown">
          <option value="">-- Select Streamer 3 --</option>
        </select>
      </div>
      <div style="display: flex; gap: 12px; margin-top: 20px;">
        <button class="btn btn-primary" id="load-streams-btn" style="flex: 1;">Load Streams</button>
        <button class="btn btn-accent" onclick="loadSampleStreamers()" style="flex: 0 0 auto;">Load Sample</button>
        <button class="btn btn-warning" onclick="populateStreamerDropdowns()" style="flex: 0 0 auto;">üîÑ Refresh Live Streamers</button>
      </div>
    </div>

    <div id="multistream" class="grid" aria-label="Stream tiles">
      <div class="tile" id="tile-1" data-idx="1" tabindex="0" aria-selected="false">
        <header>
          <span>Empty</span>
          <button class="btn" style="background:#334155" onclick="selectTile(1)">Select</button>
        </header>
        <div class="player"></div>
      </div>
      <div class="tile" id="tile-2" data-idx="2" tabindex="0" aria-selected="false">
        <header>
          <span>Empty</span>
          <button class="btn" style="background:#334155" onclick="selectTile(2)">Select</button>
        </header>
        <div class="player"></div>
      </div>
      <div class="tile" id="tile-3" data-idx="3" tabindex="0" aria-selected="false">
        <header>
          <span>Empty</span>
          <button class="btn" style="background:#334155" onclick="selectTile(3)">Select</button>
        </header>
        <div class="player"></div>
      </div>
    </div>
  </div>

  <script src="https://embed.twitch.tv/embed/v1.js"></script>
  <script>
          // Function to populate streamer dropdowns with live streamers
   async function populateStreamerDropdowns() {
     // Define dropdowns outside try block so it's accessible in finally
     const dropdowns = ['s1', 's2', 's3'];
     
     console.log('Starting populateStreamerDropdowns function...');
     console.log('Dropdown IDs:', dropdowns);
     
     try {
       // Show loading state
       dropdowns.forEach(id => {
         const dropdown = document.getElementById(id);
         console.log('Found dropdown:', id, dropdown);
         if (dropdown) {
           dropdown.classList.add('loading');
         }
       });
       
       // First try localStorage cache - check both cache keys used by main page and stream page
      let allPlayers = [];
      const mainPageCache = localStorage.getItem('leaderboard_cache');
      const streamPageCache = localStorage.getItem('leaderboardCache');
      
      if (mainPageCache) {
        try {
          const cache = JSON.parse(mainPageCache);
          if (cache.data && Array.isArray(cache.data)) {
            allPlayers = cache.data;
            console.log('Using main page cached data:', allPlayers.length);
          } else if (cache.data && cache.data.players && Array.isArray(cache.data.players)) {
            allPlayers = cache.data.players;
            console.log('Using main page cached data.players:', allPlayers.length);
          } else {
            console.log('Main page cached data structure not recognized:', cache);
          }
        } catch (e) {
          console.error('Error parsing main page cache:', e);
        }
      }
      
      // If no main page cache, try stream page cache
      if (allPlayers.length === 0 && streamPageCache) {
        try {
          const cache = JSON.parse(streamPageCache);
          if (cache.data && Array.isArray(cache.data)) {
            allPlayers = cache.data;
            console.log('Using stream page cached data:', allPlayers.length);
          } else {
            console.log('Stream page cached data is not an array, will fetch from API');
          }
        } catch (e) {
          console.error('Error parsing stream page cache:', e);
        }
      }
      
      // If no cache, fetch from leaderboard API
      if (allPlayers.length === 0) {
        try {
          console.log('No cached data, fetching from API...');
          const response = await fetch('/api/stats/PC');
          console.log('API response:', response);
          console.log('Response status:', response.status);
          console.log('Response ok:', response.ok);
          
          if (response.ok) {
            const data = await response.json();
            console.log('API response data:', data);
            console.log('data.data type:', typeof data.data);
            console.log('data.data value:', data.data);
            console.log('data.data keys:', data.data ? Object.keys(data.data) : 'null/undefined');
            
            if (data.success && data.data) {
              // The main page shows data.data.players is where the actual player array is
              if (data.data.players && Array.isArray(data.data.players)) {
                allPlayers = data.data.players;
                console.log('Found players array in data.data.players:', allPlayers.length);
              } else if (Array.isArray(data.data)) {
                allPlayers = data.data;
                console.log('data.data is directly an array:', allPlayers.length);
              } else {
                console.log('data.data structure:', data.data);
                console.log('data.data keys:', Object.keys(data.data));
                // Try to find any array in the response
                const findArray = (obj) => {
                  if (Array.isArray(obj)) return obj;
                  if (typeof obj === 'object' && obj !== null) {
                    for (const key in obj) {
                      if (Array.isArray(obj[key])) return obj[key];
                      const result = findArray(obj[key]);
                      if (result) return result;
                    }
                  }
                  return null;
                };
                const foundArray = findArray(data);
                if (foundArray) {
                  allPlayers = foundArray;
                  console.log('Found array in response:', foundArray.length);
                } else {
                  console.log('No array found in response');
                }
              }
              
              console.log('Final allPlayers:', allPlayers);
              console.log('allPlayers length:', allPlayers ? allPlayers.length : 'null/undefined');
             
              if (allPlayers && allPlayers.length > 0) {
                // Store in both cache keys for compatibility
                try {
                  localStorage.setItem('leaderboard_cache', JSON.stringify({
                    data: allPlayers,
                    timestamp: Date.now()
                  }));
                  localStorage.setItem('leaderboardCache', JSON.stringify({
                    data: allPlayers,
                    timestamp: Date.now()
                  }));
                  console.log('Cached data in both locations');
                } catch (e) {
                  console.warn('Failed to cache data:', e);
                }
              }
            } else {
              console.log('API response not successful or no data');
            }
          } else {
            console.error('API response not ok:', response.status, response.statusText);
          }
        } catch (fetchError) {
          console.error('Error fetching leaderboard:', fetchError);
        }
      }
       
       // Ensure allPlayers is always an array before filtering
       if (!Array.isArray(allPlayers)) {
         console.log('allPlayers is not an array, resetting to empty array');
         allPlayers = [];
       }
       
       // Filter for live streamers - same logic as main page
       const liveStreamers = allPlayers.filter(player => {
         const twitchLive = player.twitch_live?.is_live === true;
         const hasUser = !!(player.stream?.twitchUser || player.canonical_twitch_username || player.twitch_link);
         return twitchLive && hasUser;
       });
       
       console.log('Live streamers found:', liveStreamers.length);
       
       // Populate all three dropdowns
       dropdowns.forEach(dropdownId => {
         const dropdown = document.getElementById(dropdownId);
         const placeholder = dropdown.options[0];
         dropdown.innerHTML = '';
         dropdown.appendChild(placeholder);
         
         console.log(`Populating dropdown ${dropdownId} with ${liveStreamers.length} streamers`);
         
         // Add live streamers - same as main page
         liveStreamers.forEach(player => {
           const twitchUsername = player.stream?.twitchUser || player.canonical_twitch_username || (player.twitch_link ? extractUsernameFromLink(player.twitch_link) : null);
           const viewerCount = player.stream?.viewers || 0;
           
           if (twitchUsername) {
             const option = document.createElement('option');
             option.value = twitchUsername;
             option.textContent = `${player.name || player.player_name || twitchUsername} (${viewerCount.toLocaleString()} viewers)`;
             option.dataset.playerName = player.name || player.player_name;
             dropdown.appendChild(option);
             console.log(`Added option: ${twitchUsername} - ${player.name || player.player_name} (${viewerCount} viewers)`);
           }
         });
         
         console.log(`Dropdown ${dropdownId} now has ${dropdown.options.length} options`);
       });
        
        // Add change event listeners to auto-load streams
        dropdowns.forEach(dropdownId => {
          const dropdown = document.getElementById(dropdownId);
          dropdown.onchange = () => {
            console.log(`Dropdown ${dropdownId} changed to:`, dropdown.value);
            // Auto-load streams when selection changes
            setTimeout(() => loadStreams(), 100);
          };
        });
               
       // Show success message
       if (liveStreamers.length > 0) {
         showMessage(`Found ${liveStreamers.length} live streamers!`, 'success');
       } else {
         showMessage('No live streamers found. Try refreshing.', 'info');
       }
        
      } catch (error) {
        console.error('Error populating streamer dropdowns:', error);
        showMessage('Failed to load live streamers.', 'info');
      } finally {
        // Remove loading state
        dropdowns.forEach(id => {
          const dropdown = document.getElementById(id);
          dropdown.classList.remove('loading');
        });
      }
    }
    
    // Helper function to extract username from Twitch link
    function extractUsernameFromLink(link) {
      if (!link) return null;
      const match = link.match(/twitch\.tv\/([a-zA-Z0-9_]+)/);
      return match ? match[1].toLowerCase() : null;
    }
    
    // Modern StreamManager Class - Complete Streaming System Rewrite
    class StreamManager {
      constructor() {
        this.streams = new Map(); // Map<tileIndex, {player, channel, container}>
        this.tiles = [null, document.getElementById('tile-1'), document.getElementById('tile-2'), document.getElementById('tile-3')];
        this.dropdowns = ['s1', 's2', 's3'];
        this.selectedTileIndex = null;
        this.loadingStates = new Map(); // Track loading states per tile
        
        this.init();
      }
      
      async init() {
        console.log('üéÆ Initializing Modern StreamManager...');
        
        // Wait for Twitch embed library
        await this.waitForTwitchAPI();
        
        // Setup dropdown change listeners for real-time loading
        this.setupDropdownListeners();
        
        console.log('‚úÖ StreamManager initialized successfully');
      }
      
      async waitForTwitchAPI() {
        const maxAttempts = 50;
        let attempts = 0;
        
        while (typeof Twitch === 'undefined' && attempts < maxAttempts) {
          console.log(`‚è≥ Waiting for Twitch API... (${attempts + 1}/${maxAttempts})`);
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        if (typeof Twitch === 'undefined') {
          throw new Error('Twitch Embed API failed to load');
        }
        
        console.log('‚úÖ Twitch Embed API loaded successfully');
      }
      
      setupDropdownListeners() {
        this.dropdowns.forEach((dropdownId, index) => {
          const dropdown = document.getElementById(dropdownId);
          const tileIndex = index + 1;
          
          if (dropdown) {
            // Remove any existing listeners
            dropdown.removeEventListener('change', this.handleDropdownChange);
            
            // Add new listener with proper context binding
            dropdown.addEventListener('change', async (event) => {
              const selectedChannel = event.target.value.trim();
              console.log(`üîÑ Dropdown ${dropdownId} changed to: "${selectedChannel}"`);
              
              if (selectedChannel) {
                await this.loadStreamToTile(tileIndex, selectedChannel);
              } else {
                await this.clearTile(tileIndex);
              }
              
              // Auto-select first active tile
              this.updateSelectedTile();
            });
            
            console.log(`üéß Listener attached to dropdown: ${dropdownId}`);
          }
        });
      }
      
      async loadStreamToTile(tileIndex, channel) {
        console.log(`üöÄ Loading stream "${channel}" to tile ${tileIndex}`);
        
        try {
          // Clear existing stream first
          await this.clearTile(tileIndex);
          
          // Show loading state
          this.setLoadingState(tileIndex, true);
          
          // Create container for the new stream
          const container = this.createStreamContainer(tileIndex, channel);
          
          // Initialize Twitch Embed
          const player = await this.initializeTwitchEmbed(container.id, channel);
          
          // Store stream data
          this.streams.set(tileIndex, {
            player,
            channel,
            container,
            tileIndex
          });
          
          // Update tile UI
          this.updateTileUI(tileIndex, channel, true);
          
          console.log(`‚úÖ Successfully loaded stream "${channel}" to tile ${tileIndex}`);
          
        } catch (error) {
          console.error(`‚ùå Failed to load stream "${channel}" to tile ${tileIndex}:`, error);
          this.showStreamError(tileIndex, channel, error.message);
        } finally {
          this.setLoadingState(tileIndex, false);
        }
      }
      
      createStreamContainer(tileIndex, channel) {
        const tile = this.tiles[tileIndex];
        const playerDiv = tile.querySelector('.player');
        
        // Create unique container ID
        const containerId = `twitch-embed-${tileIndex}-${Date.now()}`;
        
        // Create container with proper structure
        playerDiv.innerHTML = `
          <div id="${containerId}" class="twitch-embed-container" data-channel="${channel}"></div>
        `;
        
        return document.getElementById(containerId);
      }
      
      async initializeTwitchEmbed(containerId, channel) {
        return new Promise((resolve, reject) => {
          const parent = location.hostname;
          
          console.log(`üé¨ Initializing Twitch Embed for "${channel}" in container "${containerId}"`);
          
          try {
            const embed = new Twitch.Embed(containerId, {
              width: '100%',
              height: '100%',
              channel: channel,
              parent: [parent],
              layout: 'video',
              theme: 'dark',
              autoplay: false,
              muted: true,
              allowfullscreen: false
            });
            
            // Handle embed events
            embed.addEventListener(Twitch.Embed.VIDEO_READY, () => {
              console.log(`‚úÖ Twitch embed ready for "${channel}"`);
              
              const player = embed.getPlayer();
              if (player) {
                // Set optimal volume
                player.setVolume(0.5);
                
                // Add player event listeners
                player.addEventListener(Twitch.Player.READY, () => {
                  console.log(`üéÆ Player ready for "${channel}"`);
                });
                
                player.addEventListener(Twitch.Player.PLAY, () => {
                  console.log(`‚ñ∂Ô∏è Stream playing: "${channel}"`);
                });
                
                player.addEventListener(Twitch.Player.PAUSE, () => {
                  console.log(`‚è∏Ô∏è Stream paused: "${channel}"`);
                });
                
                player.addEventListener(Twitch.Player.ENDED, () => {
                  console.log(`‚èπÔ∏è Stream ended: "${channel}"`);
                });
                
                player.addEventListener(Twitch.Player.OFFLINE, () => {
                  console.log(`üì¥ Stream offline: "${channel}"`);
                  this.showStreamOffline(containerId, channel);
                });
              }
              
              resolve(embed);
            });
            
            // Handle errors
            embed.addEventListener(Twitch.Embed.VIDEO_PLAY, () => {
              console.log(`‚ñ∂Ô∏è Embed video playing: "${channel}"`);
            });
            
            // Timeout fallback
            setTimeout(() => {
              if (embed) {
                console.log(`‚ö†Ô∏è Embed loaded with timeout for "${channel}"`);
                resolve(embed);
              } else {
                reject(new Error(`Timeout loading embed for "${channel}"`));
              }
            }, 10000);
            
          } catch (error) {
            console.error(`‚ùå Twitch Embed creation failed for "${channel}":`, error);
            reject(error);
          }
        });
      }
      
      async clearTile(tileIndex) {
        console.log(`üßπ Clearing tile ${tileIndex}`);
        
        // Clean up existing stream
        if (this.streams.has(tileIndex)) {
          const streamData = this.streams.get(tileIndex);
          
          try {
            // Destroy Twitch player
            if (streamData.player && typeof streamData.player.destroy === 'function') {
              streamData.player.destroy();
              console.log(`üóëÔ∏è Destroyed player for tile ${tileIndex}`);
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è Error destroying player for tile ${tileIndex}:`, error);
          }
          
          this.streams.delete(tileIndex);
        }
        
        // Clear tile UI
        this.updateTileUI(tileIndex, '', false);
        
        // Clear container
        const tile = this.tiles[tileIndex];
        const playerDiv = tile.querySelector('.player');
        playerDiv.innerHTML = '';
        
        console.log(`‚úÖ Tile ${tileIndex} cleared successfully`);
      }
      
      setLoadingState(tileIndex, isLoading) {
        this.loadingStates.set(tileIndex, isLoading);
        
        const tile = this.tiles[tileIndex];
        const playerDiv = tile.querySelector('.player');
        
        if (isLoading) {
          playerDiv.innerHTML = `
            <div class="stream-loading">
              <div class="loading-spinner"></div>
              <p>Loading stream...</p>
            </div>
          `;
          tile.classList.add('loading');
        } else {
          tile.classList.remove('loading');
        }
      }
      
      updateTileUI(tileIndex, channel, hasStream) {
        const tile = this.tiles[tileIndex];
        const header = tile.querySelector('header span');
        
        if (hasStream && channel) {
          header.textContent = channel;
          tile.dataset.username = channel;
          tile.classList.add('has-stream');
          tile.classList.remove('error');
        } else {
          header.textContent = 'Empty';
          tile.dataset.username = '';
          tile.classList.remove('has-stream', 'error');
        }
      }
      
      showStreamError(tileIndex, channel, errorMessage) {
        const tile = this.tiles[tileIndex];
        const playerDiv = tile.querySelector('.player');
        
        playerDiv.innerHTML = `
          <div class="stream-error">
            <div class="error-icon">‚ùå</div>
            <p class="error-title">Failed to load stream</p>
            <p class="error-channel">"${channel}"</p>
            <p class="error-message">${errorMessage}</p>
            <button class="retry-btn" onclick="streamManager.retryStream(${tileIndex}, '${channel}')">
              üîÑ Retry
            </button>
          </div>
        `;
        
        tile.classList.add('error');
        this.updateTileUI(tileIndex, channel, false);
        
        console.error(`üí• Stream error displayed for tile ${tileIndex}`);
      }
      
      showStreamOffline(containerId, channel) {
        const container = document.getElementById(containerId);
        if (container) {
          container.innerHTML = `
            <div class="stream-offline">
              <div class="offline-icon">üì¥</div>
              <p class="offline-title">Stream Offline</p>
              <p class="offline-channel">"${channel}"</p>
              <p class="offline-message">This streamer is currently offline</p>
            </div>
          `;
        }
      }
      
      async retryStream(tileIndex, channel) {
        console.log(`üîÑ Retrying stream "${channel}" on tile ${tileIndex}`);
        await this.loadStreamToTile(tileIndex, channel);
      }
      
      updateSelectedTile() {
        // Auto-select first tile with active stream
        const activeStreams = Array.from(this.streams.keys());
        if (activeStreams.length > 0) {
          const firstActive = Math.min(...activeStreams);
          this.selectTile(firstActive);
        }
      }
      
      selectTile(tileIndex) {
        console.log(`üéØ Selecting tile ${tileIndex}`);
        
        // Update visual selection
        this.tiles.forEach((tile, idx) => {
          if (tile) {
            tile.removeAttribute('data-selected');
            tile.setAttribute('aria-selected', 'false');
          }
        });
        
        if (this.tiles[tileIndex]) {
          this.tiles[tileIndex].setAttribute('data-selected', 'true');
          this.tiles[tileIndex].setAttribute('aria-selected', 'true');
          this.selectedTileIndex = tileIndex;
        }
      }
      
      // Public API methods
      getCurrentSelectedStream() {
        return this.selectedTileIndex ? this.streams.get(this.selectedTileIndex) : null;
      }
      
      getAllActiveStreams() {
        return Array.from(this.streams.values());
      }
      
      async refreshAllStreams() {
        console.log('üîÑ Refreshing all active streams...');
        
        const refreshPromises = [];
        for (const [tileIndex, streamData] of this.streams) {
          refreshPromises.push(this.loadStreamToTile(tileIndex, streamData.channel));
        }
        
        await Promise.all(refreshPromises);
        console.log('‚úÖ All streams refreshed');
      }
      
      destroy() {
        console.log('üß® Destroying StreamManager...');
        
        // Clear all streams
        const clearPromises = [];
        for (const tileIndex of this.streams.keys()) {
          clearPromises.push(this.clearTile(tileIndex));
        }
        
        return Promise.all(clearPromises);
      }
    }
    
    // Initialize the StreamManager
    let streamManager = null;
    
    // Initialize StreamManager when page loads
    async function initializeStreamManager() {
      try {
        console.log('üöÄ Initializing StreamManager...');
        streamManager = new StreamManager();
        console.log('‚úÖ StreamManager initialized successfully');
      } catch (error) {
        console.error('‚ùå Failed to initialize StreamManager:', error);
        showMessage('Failed to initialize streaming system', 'error');
      }
    }
    
    // Legacy compatibility functions (for external scripts)
    function selectTile(idx) {
      if (streamManager) {
        streamManager.selectTile(idx);
      }
    }
    
    function getCurrentStreamFocus() {
      if (streamManager) {
        const selectedStream = streamManager.getCurrentSelectedStream();
        return selectedStream ? selectedStream.channel : null;
      }
      return null;
    }
    
    // Modern loadStreams function - now works with StreamManager
    async function loadStreams() {
      if (!streamManager) {
        console.warn('‚ö†Ô∏è StreamManager not initialized yet, waiting...');
        setTimeout(() => loadStreams(), 500);
        return;
      }
      
      console.log('üöÄ Loading streams via StreamManager...');
      
      const dropdowns = [
        { id: 's1', tile: 1 },
        { id: 's2', tile: 2 },
        { id: 's3', tile: 3 }
      ];
      
      const loadPromises = dropdowns.map(async ({ id, tile }) => {
        const dropdown = document.getElementById(id);
        const selectedChannel = dropdown.value.trim();
        
        if (selectedChannel) {
          console.log(`üì∫ Loading "${selectedChannel}" to tile ${tile}`);
          await streamManager.loadStreamToTile(tile, selectedChannel);
        } else {
          console.log(`üßπ Clearing tile ${tile} (no selection)`);
          await streamManager.clearTile(tile);
        }
      });
      
      try {
        await Promise.all(loadPromises);
        console.log('‚úÖ All streams loaded successfully');
        showMessage('Streams loaded successfully!', 'success');
      } catch (error) {
        console.error('‚ùå Error loading streams:', error);
        showMessage('Error loading some streams', 'error');
      }
    }
    
    function loadSampleStreamers() {
      console.log('üéØ Loading sample streamers...');
      
      // Set sample streamers in dropdowns
      const sampleStreamers = ['aceu', 'shroud', 'iitztimmy'];
      const dropdowns = [
        document.getElementById('s1'),
        document.getElementById('s2'), 
        document.getElementById('s3')
      ];
      
      // Set sample streamers and trigger change events for auto-loading
      sampleStreamers.forEach((username, index) => {
        const dropdown = dropdowns[index];
        if (dropdown) {
          // Try to find the streamer in dropdown options first
          let found = false;
          for (let i = 0; i < dropdown.options.length; i++) {
            if (dropdown.options[i].value === username) {
              dropdown.selectedIndex = i;
              found = true;
              break;
            }
          }
          
          // If not found in options, set value directly
          if (!found) {
            dropdown.value = username;
          }
          
          // Trigger change event to auto-load via StreamManager
          dropdown.dispatchEvent(new Event('change'));
          console.log(`üì∫ Set sample streamer "${username}" in dropdown ${index + 1}`);
        }
      });
      
      console.log('‚úÖ Sample streamers configured and loading...');
    }
    
    function showMessage(message, type = 'info') {
      const existing = document.querySelector('.message');
      if (existing) existing.remove();
      
      const msg = document.createElement('div');
      msg.className = `message message-${type}`;
      msg.textContent = message;
      msg.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        z-index: 1000;
        background: ${type === 'success' ? '#22c55e' : type === 'error' ? '#dc2626' : '#3b82f6'};
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      
      document.body.appendChild(msg);
      setTimeout(() => msg.remove(), 3000);
    }
    
    // Helpers used by multistream-clips.js
    window.getCurrentStreamFocus = function () {
      const focused = document.querySelector('[data-selected="true"][data-idx]');
      return focused ? (focused.dataset.username || null) : null;
    }
    
    // Auto-populate dropdowns with live streamers on page load
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üé¨ Page loaded, initializing systems...');
      
      // First populate dropdowns with live streamers
      await populateStreamerDropdowns();
      
      // Then initialize the modern StreamManager
      await initializeStreamManager();
      
      // Hide the legacy Load Streams button since auto-loading is now active
      const loadStreamsBtn = document.getElementById('load-streams-btn');
      if (loadStreamsBtn) {
        loadStreamsBtn.style.display = 'none';
        console.log('‚úÖ Legacy Load Streams button hidden - auto-loading is now active');
      }
      
      console.log('üéâ All systems initialized successfully!');
    });
  </script>

   <script src="/js/multistream-clips.js?v=stream-1"></script>
 </body>
 </html>


