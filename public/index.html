<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Chosen Palette: Deep Dark (Black/Dark Gray), Muted Grays, with Emerald Green, Indigo, and Red Accents) -->
    <!-- Application Structure Plan: A top-down dashboard structure was chosen for optimal information hierarchy, now enhanced with top-level tabbed navigation. The 'Leaderboard' tab provides an immediate snapshot of high-level key metrics (Predator Thresholds) and an interactive data table for detailed exploration (Leaderboard), equipped with search, filter, pagination, data visualizations, and Twitch override. A new 'Player Stats & Match History' tab offers a dedicated interface for individual player lookups, allowing users to query by name/UID and platform. This tab will display detailed player statistics. This tabbed approach provides clear functional separation, improving user understanding and ease of navigation by allowing users to switch contexts easily without leaving the single page. -->
    <!-- Visualization & Content Choices: 
        - Predator Thresholds -> Goal: Inform -> Presentation: 4-Card Layout -> Interaction: None -> Justification: Key metrics are best presented as prominent, easily scannable cards at the top.
        - Leaderboard Data -> Goal: Organize/Compare/Explore -> Presentation: Interactive HTML Table with Pagination -> Interaction: Search, Live-Only Toggle, Hover for Twitch Preview, Click for AI Analysis, Pagination Controls (Next/Previous/Page Numbers) -> Justification: A table is essential for displaying detailed, multi-column data. The interactions allow users to drill down and find specific information efficiently, and pagination prevents overwhelming the user with too much data at once.
        - Top 20 Player RP -> Goal: Compare -> Presentation: Bar Chart (Chart.js) -> Interaction: Hover for Tooltip -> Justification: A bar chart provides a much faster and more intuitive way to compare the RP of top players than scanning a table column.
        - Masters & Predators by Platform -> Goal: Compare/Inform -> Presentation: Doughnut Chart (Chart.js) -> Interaction: Hover for Tooltip -> Justification: A doughnut chart is excellent for showing the proportional distribution of the player base across different platforms, offering a high-level summary.
        - Twitch Override Management -> Goal: Manage Data -> Presentation: Input Form within Modal -> Interaction: Text Input, Submit Button -> Justification: Provides direct user control over specific data points (Twitch links), making the application more dynamic and responsive to user needs.
        - Player Stats & Match History -> Goal: Inform/Explore (Individual) -> Presentation: Input Form, Dynamic Text/Stat Display with Legend Tips and Match History, API Selection -> Interaction: Text Input, Select Dropdown, Submit Button, Click for Legend Tips, Radio Buttons for API Selection -> Justification: Allows granular lookup of specific player data from multiple sources, complementing the aggregate leaderboard view, and provides AI-generated lore and tips for selected legends, and detailed match history.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Apex Legends Leaderboard SPA</title>
    
    <!-- CDNs -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://embed.twitch.tv/embed/v1.js"></script>
    <!-- Split.js for best-in-class resizable panes -->
    <script src="https://unpkg.com/split.js/dist/split.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #0c0a09; /* Deep dark background */
            color: #e5e7eb; /* Light gray text */
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .toggle-checkbox:checked { transform: translateX(100%); border-color: #10B981; }
        .toggle-checkbox:checked + .toggle-label { background-color: #10B981; }
        @keyframes pulse-live { 
            0%, 100% { transform: scale(1); box-shadow: 0 0 3px #ef4444, 0 0 5px #ef4444; } 
            50% { transform: scale(1.05); box-shadow: 0 0 10px #ef4444, 0 0 15px #ef4444; } 
        }
        .animate-live-pulse { animation: pulse-live 2.5s infinite ease-in-out; }
        #stream-preview { 
            position: fixed; z-index: 50; width: 320px; height: 180px; 
            border: 1px solid #4b5563; border-radius: 0.5rem; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); 
            overflow: hidden; pointer-events: none; 
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out; 
            opacity: 0; transform: scale(0.95); 
        }
        .modal {
            position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show { opacity: 1; visibility: visible; }
        .modal-content {
            background-color: #1f2937; /* Darker gray for modal content */
            margin: auto; padding: 24px;
            border-radius: 0.75rem; border: 1px solid #4b5563;
            width: 90%; max-width: 600px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transform: translateY(-20px); transition: transform 0.3s ease;
        }
        
        /* Special styling for multistream modal */
        .multistream-modal .modal-content {
            max-width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 24px;
        }
        .modal.show .modal-content { transform: translateY(0); }
        .close-button {
            color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;
        }
        .close-button:hover, .close-button:focus { color: white; }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #3b82f6;
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 400px;
            max-height: 50vh;
        }
        /* Tab styles */
        .tab-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            background-color: #1f2937;
            color: #9ca3af;
            font-weight: 600;
            transition: all 0.2s ease;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            background-color: #0c0a09;
            color: #ffffff;
            border-bottom-color: #4f46e5; /* Indigo-600 */
        }
        
        /* Navigation Styles */
        .nav-item {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 12px 16px;
            text-align: left;
            color: #9ca3af;
            background: none;
            border: none;
            border-radius: 12px;
            font-weight: 500;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 4px;
        }
        
        .nav-item:hover {
            background-color: rgba(55, 65, 81, 0.5);
            color: #ffffff;
        }
        
        .nav-item.active {
            background-color: rgba(79, 70, 229, 0.2);
            color: #6366f1;
            font-weight: 600;
        }
        
        .nav-item svg {
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .nav-item span {
            font-size: 16px;
        }
        
        /* Animated Background Options */
        
        /* Option 1: Apex Legends inspired gradient with subtle animation */
        body {
            background: linear-gradient(-45deg, #0f0f1e, #1a1a2e, #16213e, #0f0f1e);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Option 2: Floating particles overlay (uncomment to use instead) */
        /*
        body {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f1e 100%);
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.1), transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.1), transparent),
                radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.1), transparent);
            background-size: 200px 100px, 300px 150px, 250px 120px;
            animation: particleFloat 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes particleFloat {
            0% { background-position: 0px 0px, 0px 0px, 0px 0px; }
            100% { background-position: 500px 1000px, -500px 1000px, 500px -1000px; }
        }
        */
        
        /* Option 3: Gaming RGB wave effect (uncomment to use instead) */
        /*
        body {
            background: linear-gradient(-45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 400%;
            animation: rgbWave 8s ease infinite;
        }
        
        @keyframes rgbWave {
            0% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 100% 100%; }
            75% { background-position: 50% 100%; }
            100% { background-position: 0% 50%; }
        }
        */
        
        /* Ensure content is above background */
        .main-container {
            position: relative;
            z-index: 1;
        }
        .tab-content {
            display: none;
            padding-top: 1rem;
            border-top: 3px solid #1f2937;
        }
        .tab-content.active {
            display: block;
        }
        /* New styles for nicer UI */
        .stat-card {
            background-color: #1f2937; /* bg-gray-800 */
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid #374151; /* border-gray-700 */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        .legend-card {
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            min-height: 250px;
        }
        .legend-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to top, rgba(31, 41, 55, 1) 10%, rgba(31, 41, 55, 0.7) 50%, rgba(31, 41, 55, 0.4) 100%);
            z-index: 1;
        }
        .legend-card > * {
            position: relative;
            z-index: 2;
        }
        .match-card {
            background-color: #273344;
            border-left: 4px solid #4f46e5; /* Indigo */
            padding: 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease;
        }
        .match-card:hover {
            background-color: #374151;
        }
        
        /* Ensure Twitch embeds fill their containers properly */
        .twitch-embed-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .twitch-embed-container iframe {
            width: 100% !important;
            height: 100% !important;
            border: none;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Smooth transition for loading indicator */
        .loading-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        
        /* Ensure proper spacing between stream elements */
        .stream-header {
            padding: 12px 16px;
            border-bottom: 1px solid #4b5563;
        }
        
        /* Rank badge styling */
        .rank-badge {
            filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.3));
            object-fit: contain;
        }
        
        .predator-badge {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Live indicator pulse */
        .live-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .api-source-label {
            padding: 0.5rem 1rem;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .api-source-radio:checked + .api-source-label {
            background-color: #4f46e5;
            border-color: #4f46e5;
            color: white;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }
        .api-source-radio {
            display: none;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Contact Banner -->
    <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white py-3 px-4 text-center shadow-lg">
        <div class="container mx-auto flex items-center justify-center space-x-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
            </svg>
            <span class="font-semibold">Contact:</span>
            <span class="font-mono bg-black/20 px-2 py-1 rounded">razapookie</span>
            <span>on Discord</span>
        </div>
    </div>

    <!-- Account Button (Supabase Auth) -->
    <div id="accountButtonContainer" class="fixed top-4 right-4 z-50">
        <div id="accountButton" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg shadow-lg cursor-pointer transition-colors duration-200 flex items-center space-x-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 12a5 5 0 100-10 5 5 0 000 10zm-7 9a7 7 0 0114 0v1H5v-1z"/></svg>
            <span id="accountStatus">Sign in</span>
        </div>
    </div>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-white">Apex Legends Ranked Dashboard</h1>
            <p class="text-gray-300 mt-2">Live insights into the Predator leaderboards and platform statistics.</p>
            <div id="authControls" class="mt-3"></div>
        </header>

        <!-- Auth Modal -->
        <div id="authModal" class="fixed inset-0 bg-black/60 z-50 hidden items-center justify-center">
            <div class="bg-gray-800 rounded-lg p-5 w-full max-w-sm shadow-xl">
                <h3 class="text-white text-lg font-semibold mb-3">Account</h3>
                <div id="authTabs" class="flex gap-2 mb-4 hidden">
                    <button id="authTabEmail" class="px-3 py-1.5 rounded bg-gray-700 text-sm flex items-center gap-2">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M4 4h16a2 2 0 012 2v12a2 2 0 01-2 2H4a2 2 0 01-2-2V6a2 2 0 012-2zm0 2v.01L12 13l8-6.99V6H4z"/></svg>
                        <span>Email link</span>
                    </button>
                    <button id="authTabPassword" class="px-3 py-1.5 rounded bg-gray-700 text-sm flex items-center gap-2">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 1a5 5 0 00-5 5v3H6a2 2 0 00-2 2v9a2 2 0 002 2h12a2 2 0 002-2v-9a2 2 0 00-2-2h-1V6a5 5 0 00-5-5zm-3 8V6a3 3 0 116 0v3H9z"/></svg>
                        <span>Email + password</span>
                    </button>
                    <button id="authTabGoogle" class="px-3 py-1.5 rounded bg-gray-700 text-sm flex items-center gap-2">
                        <svg class="w-4 h-4" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.5 0 6.6 1.2 9 3.2l6.7-6.7C35.6 2.3 30.2 0 24 0 14.6 0 6.5 5.4 2.6 13.3l7.8 6.1C12 13.3 17.5 9.5 24 9.5z"/><path fill="#4285F4" d="M46.5 24.5c0-1.7-.2-3.3-.6-4.9H24v9.3h12.7c-.5 2.7-2.1 5-4.4 6.5l7 5.4c4.1-3.8 6.2-9.4 6.2-16.3z"/><path fill="#FBBC05" d="M10.4 28.1c-.5-1.6-.8-3.3-.8-5.1s.3-3.5.8-5.1l-7.8-6.1C.9 14.3 0 18.1 0 23s.9 8.7 2.6 11.2l7.8-6.1z"/><path fill="#34A853" d="M24 48c6.2 0 11.5-2 15.3-5.6l-7-5.4c-2.1 1.4-4.8 2.2-8.3 2.2-6.5 0-12-3.8-13.7-9l-7.8 6.1C6.5 42.6 14.6 48 24 48z"/></svg>
                        <span>Google</span>
                    </button>
                    <button id="authTabTwitch" class="px-3 py-1.5 rounded bg-gray-700 text-sm flex items-center gap-2">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M11.571 4.714h1.715v5.143H11.57zm4.714 0h1.715v5.143h-1.715zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0H6zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714v9.429z"/></svg>
                        <span>Twitch</span>
                    </button>
                </div>
                <!-- Email Link -->
                <div id="authEmailLinkSection">
                    <p class="text-sm text-gray-400 mb-3">We'll email you a magic link to sign in.</p>
                    <input id="loginEmail" type="email" placeholder="you@example.com" class="w-full px-3 py-2 rounded bg-gray-700 text-white mb-3" />
                    <div id="emailSentMsg" class="hidden text-emerald-400 text-sm mb-3">Magic link sent. Check your inbox.</div>
                    <div class="flex gap-2 justify-end">
                        <button id="loginCancelBtn" class="px-3 py-2 rounded bg-gray-700 hover:bg-gray-600">Cancel</button>
                        <button id="loginSendBtn" class="px-3 py-2 rounded bg-purple-600 hover:bg-purple-700">Send link</button>
                    </div>
                </div>
                <!-- Email + Password -->
                <div id="authPasswordSection" class="">
                    <input id="pwEmail" type="email" placeholder="you@example.com" class="w-full px-3 py-2 rounded bg-gray-700 text-white mb-2" />
                    <input id="pwPassword" type="password" placeholder="password" class="w-full px-3 py-2 rounded bg-gray-700 text-white mb-2" />
                    <div class="flex items-center justify-between mb-3">
                        <button id="pwResetBtn" class="text-xs text-blue-400 hover:text-blue-300">Forgot your password?</button>
                        <button id="pwSignupToggle" class="text-xs text-blue-400 hover:text-blue-300">Sign up</button>
                    </div>
                    <div id="pwMsg" class="hidden text-emerald-400 text-sm mb-3"></div>
                    <button id="pwSubmitBtn" class="w-full mb-4 px-3 py-2 rounded bg-purple-600 hover:bg-purple-700">Sign in</button>
                    <div class="flex items-center gap-2 my-2 text-gray-400 text-xs"><div class="h-px flex-1 bg-gray-700"></div><span>Or continue with</span><div class="h-px flex-1 bg-gray-700"></div></div>
                    <div class="flex flex-col gap-2">
                        <button id="googleSignInBtn" class="w-full inline-flex items-center justify-center gap-2 px-3 py-2 rounded bg-white text-gray-800">
                            <svg class="w-5 h-5" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.5 0 6.6 1.2 9 3.2l6.7-6.7C35.6 2.3 30.2 0 24 0 14.6 0 6.5 5.4 2.6 13.3l7.8 6.1C12 13.3 17.5 9.5 24 9.5z"/><path fill="#4285F4" d="M46.5 24.5c0-1.7-.2-3.3-.6-4.9H24v9.3h12.7c-.5 2.7-2.1 5-4.4 6.5l7 5.4c4.1-3.8 6.2-9.4 6.2-16.3z"/><path fill="#FBBC05" d="M10.4 28.1c-.5-1.6-.8-3.3-.8-5.1s.3-3.5.8-5.1l-7.8-6.1C.9 14.3 0 18.1 0 23s.9 8.7 2.6 11.2l7.8-6.1z"/><path fill="#34A853" d="M24 48c6.2 0 11.5-2 15.3-5.6l-7-5.4c-2.1 1.4-4.8 2.2-8.3 2.2-6.5 0-12-3.8-13.7-9l-7.8 6.1C6.5 42.6 14.6 48 24 48z"/></svg>
                            <span>Continue with Google</span>
                        </button>
                        <!-- GitHub removed -->
                        <button id="twitchSignInBtn" class="w-full inline-flex items-center justify-center gap-2 px-3 py-2 rounded bg-purple-600 hover:bg-purple-700 text-white">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M11.571 4.714h1.715v5.143H11.57zm4.714 0h1.715v5.143h-1.715zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0H6zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714v9.429z"/></svg>
                            <span>Continue with Twitch</span>
                        </button>
                    </div>
                    <button id="pwCancelBtn" class="mt-4 w-full px-3 py-2 rounded bg-gray-700 hover:bg-gray-600">Cancel</button>
                </div>
                <!-- Google OAuth -->
                <div id="authGoogleSection" class="hidden">
                    <p class="text-sm text-gray-400 mb-3">Continue with a provider</p>
                    <div class="flex flex-col gap-2">
                        <button id="googleSignInBtn" class="w-full inline-flex items-center justify-center gap-2 px-3 py-2 rounded bg-white text-gray-800">
                            <svg class="w-5 h-5" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.5 0 6.6 1.2 9 3.2l6.7-6.7C35.6 2.3 30.2 0 24 0 14.6 0 6.5 5.4 2.6 13.3l7.8 6.1C12 13.3 17.5 9.5 24 9.5z"/><path fill="#4285F4" d="M46.5 24.5c0-1.7-.2-3.3-.6-4.9H24v9.3h12.7c-.5 2.7-2.1 5-4.4 6.5l7 5.4c4.1-3.8 6.2-9.4 6.2-16.3z"/><path fill="#FBBC05" d="M10.4 28.1c-.5-1.6-.8-3.3-.8-5.1s.3-3.5.8-5.1l-7.8-6.1C.9 14.3 0 18.1 0 23s.9 8.7 2.6 11.2l7.8-6.1z"/><path fill="#34A853" d="M24 48c6.2 0 11.5-2 15.3-5.6l-7-5.4c-2.1 1.4-4.8 2.2-8.3 2.2-6.5 0-12-3.8-13.7-9l-7.8 6.1C6.5 42.6 14.6 48 24 48z"/></svg>
                            <span>Continue with Google</span>
                        </button>
                        <!-- GitHub removed -->
                        <button id="googleCancelBtn" class="w-full px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 text-white">Cancel</button>
                    </div>
                </div>
                <!-- Twitch OAuth -->
                <div id="authTwitchSection" class="hidden">
                    <p class="text-sm text-gray-400 mb-3">Continue with your Twitch account.</p>
                    <div class="flex flex-col gap-2">
                        <button id="twitchSignInBtn" class="w-full inline-flex items-center justify-center gap-2 px-3 py-2 rounded bg-purple-600 hover:bg-purple-700 text-white">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M11.571 4.714h1.715v5.143H11.57zm4.714 0h1.715v5.143h-1.715zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0H6zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714v9.429z"/></svg>
                            <span>Continue with Twitch</span>
                        </button>
                        <button id="twitchCancelBtn" class="w-full px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 text-white">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Layout with Sidebar -->
        <div class="flex min-h-screen main-container">
            <!-- Twitter-Style Sidebar -->
            <div class="w-64 bg-gray-900/50 backdrop-blur-sm border-r border-gray-700/50 fixed h-full left-0 top-0 pt-20">
                <div class="p-4">
                    <nav class="space-y-2">
                        <!-- Leaderboard -->
                        <button class="nav-item active" onclick="showTab('leaderboardTab')">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            <span>Leaderboard</span>
                        </button>
                        
                        <!-- Player Stats -->
                        <button class="nav-item" onclick="showTab('playerStatsTab')">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8v8m-4-5v5m-4-2v2m-2 4h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <span>Player Stats</span>
                        </button>
                        
                        <!-- My Account -->
                        <button class="nav-item" onclick="showTab('accountTab')">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            <span>My Account</span>
                        </button>
                        
                        <!-- Multi-Stream -->
                        <a href="#" onclick="showTab('multiStreamTab'); return false;" class="nav-item">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                            </svg>
                            <span>Multi-Stream</span>
                        </a>
                        
                        <!-- Settings -->
                        <button class="nav-item" onclick="showSettingsModal()">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                            </svg>
                            <span>Settings</span>
                        </button>
                    </nav>
                </div>
        </div>
            
            <!-- Main Content Area -->
            <div class="flex-1 ml-64 p-6">

        <!-- Leaderboard Tab Content -->
        <div id="leaderboardTab" class="tab-content active">
            <section id="key-metrics" class="mb-10">
                <h2 class="text-2xl font-bold text-white mb-4">Predator Thresholds</h2>
                <div id="predator-thresholds" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div class="bg-gray-800 p-4 rounded-lg text-center text-gray-500 border border-gray-700/50">Loading PC...</div>
                    <div class="bg-gray-800 p-4 rounded-lg text-center text-gray-500 border border-gray-700/50">Loading PlayStation...</div>
                    <div class="bg-gray-800 p-4 rounded-lg text-center text-gray-500 border border-gray-700/50">Loading Xbox...</div>
                    <div class="bg-gray-800 p-4 rounded-lg text-center text-gray-500 border border-gray-700/50">Loading Switch...</div>
                </div>
            </section>

            <!-- Game Status Section -->
            <section id="game-status" class="mb-10">
                <h2 class="text-2xl font-bold text-white mb-4">Game Status</h2>
                <div class="grid grid-cols-1 gap-6 items-start">
                    <!-- Map Rotation -->
                    <div id="map-rotation" class="bg-gray-800 p-6 rounded-lg border border-gray-700/50">
                        <h3 class="font-semibold text-gray-300 mb-4 text-lg">Map Rotation</h3>
                        <div class="text-sm text-gray-400">Loading...</div>
                    </div>
                </div>
            </section>





            <section id="interactive-leaderboard" class="mb-10">
                <div class="mb-6 pb-4 border-b border-gray-700/50">
                    <h2 class="text-2xl font-bold text-white">Live Ranked Leaderboard</h2>
                </div>

                <div class="flex flex-col sm:flex-row items-center justify-between mb-4 gap-4">
                    <div class="relative w-full sm:w-auto sm:flex-grow max-w-xs">
                        <span class="absolute inset-y-0 left-0 flex items-center pl-3"><svg class="w-5 h-5 text-gray-400" viewBox="0 0 24 24" fill="none"><path d="M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></span>
                        <input type="text" id="searchInput" placeholder="Search players..." class="w-full bg-gray-800 border border-gray-700 text-white rounded-lg py-2 pl-10 pr-4 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent transition">
                    </div>
                    <div class="flex items-center space-x-4">
                        <!-- Live Streamers Counter -->
                        <div id="streamers-online" class="flex items-center space-x-2 bg-gray-800 px-3 py-2 rounded-lg border border-gray-700/50">
                            <div class="w-2 h-2 bg-emerald-500 rounded-full animate-pulse"></div>
                            <span class="text-sm font-semibold text-emerald-400" id="live-count">0</span>
                            <span class="text-xs text-gray-400">live</span>
                        </div>
                        <!-- Offline Streamers Counter -->
                        <div id="streamers-offline" class="flex items-center space-x-2 bg-gray-800 px-3 py-2 rounded-lg border border-gray-700/50">
                            <div class="w-2 h-2 bg-gray-500 rounded-full"></div>
                            <span class="text-sm font-semibold text-gray-400" id="offline-count">0</span>
                            <span class="text-xs text-gray-400">offline</span>
                        </div>
                        <!-- Total Viewers Counter -->
                        <div class="flex items-center space-x-2 bg-gray-800 px-3 py-2 rounded-lg border border-gray-700/50">
                            <div class="w-2 h-2 bg-blue-500 rounded-full"></div>
                            <span class="text-sm font-semibold text-blue-400" id="total-viewers">0</span>
                            <span class="text-xs text-gray-400">viewers</span>
                        </div>
                        <!-- Auto-Refresh Countdown Timer -->
                        <div id="refresh-countdown" class="flex items-center space-x-2 bg-gray-800 px-3 py-2 rounded-lg border border-gray-700/50">
                            <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                            <span class="text-sm text-gray-400">Next refresh:</span>
                            <span class="text-sm font-semibold text-blue-400" id="countdown-timer">60s</span>
                        </div>
                        <!-- Live Streamers Only Toggle -->
                        <div class="flex items-center space-x-3">
                            <span class="font-medium text-white">Live Streamers Only</span>
                            <div class="relative inline-block w-10 mr-2 align-middle select-none">
                                <input type="checkbox" name="toggle" id="liveOnlyToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 border-gray-600 appearance-none cursor-pointer transition-transform duration-200 ease-in"/>
                                <label for="liveOnlyToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                            </div>
                            <a href="#" onclick="showTab('multiStreamTab'); return false;" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm inline-block transition-colors">Multi-Stream</a>
            <button onclick="showSettingsModal()" class="bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm ml-2">
                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                </svg>
                Settings
            </button>
                        </div>
                    </div>
                </div>

                <div class="overflow-x-auto bg-gray-800/50 backdrop-blur-sm border border-gray-700/50 rounded-lg shadow-2xl shadow-black/30">
                    <table class="w-full min-w-max text-sm text-left text-gray-400">
                        <thead class="text-xs text-gray-300 uppercase bg-gray-700/20">
                            <tr>
                                <th scope="col" class="px-6 py-3">Rank</th><th scope="col" class="px-6 py-3">Player</th><th scope="col" class="px-6 py-3">Legend</th><th scope="col" class="px-6 py-3">RP</th>
                                <th scope="col" class="px-6 py-3">24h Change</th><th scope="col" class="px-6 py-3">Level</th><th scope="col" class="px-6 py-3">Status</th>
                                <th scope="col" class="px-6 py-3">Stream</th>
                                <th id="multiStreamHeader" scope="col" class="px-6 py-3">Multi-Stream</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-body" class="divide-y divide-gray-700/50"><tr><td colspan="9" class="text-center py-10 text-gray-400">Loading players...</td></tr></tbody>
                    </table>
                </div>

                <!-- Pagination Controls -->
                <div id="pagination-controls" class="flex justify-center items-center space-x-2 mt-4 text-gray-300">
                    <button id="prevPage" class="px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
                    <div id="pageNumbers" class="flex space-x-1"></div>
                    <button id="nextPage" class="px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">Next</button>
                </div>
            </section>

            <section id="data-visualizations" class="mb-10">
                <h2 class="text-2xl font-bold text-white mb-6 text-center">Data Visualizations</h2>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50">
                        <h3 class="text-lg font-semibold text-gray-300 mb-4 text-center">Top 20 Players by RP</h3>
                        <div class="chart-container">
                            <canvas id="rpDistributionChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50">
                        <h3 class="text-lg font-semibold text-gray-300 mb-4 text-center">Masters & Predators by Platform</h3>
                        <div class="chart-container" style="max-width: 450px; height: 400px;">
                            <canvas id="platformDistributionChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Twitch Override Management removed from main page per request -->
        </div>

        <!-- Multi-Stream Tab -->
        <div id="multiStreamTab" class="tab-content">
        <section id="multiStreamDock" class="mb-8">
            <!-- Control bar -->
            <div class="flex items-center justify-between mb-3">
                <div class="flex items-center gap-3">
                    <h2 class="text-xl font-bold text-white">Multi-Stream</h2>
                    <button id="msCollapseBtn" class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="toggleMultiStreamCollapse()">Collapse</button>
                </div>
                <div class="text-gray-400 text-sm">Drag gutters to resize. Layout presets available.</div>
            </div>

            <div class="mb-4">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <!-- Streamer 1 -->
                        <div class="space-y-3">
                            <div class="flex items-center justify-between">
                                <label class="text-sm font-medium text-gray-300">Streamer 1</label>
                                <button id="favoriteBtn1" class="text-gray-400 hover:text-red-500 transition-colors" onclick="toggleFavorite(1)">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.682l-1.318-1.364a4.5 4.5 0 00-6.364 0z"></path>
                                    </svg>
                                </button>
                            </div>
                            <select id="streamer1" class="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all">
                                <option value="">Select Streamer 1</option>
                            </select>
                        </div>
                        
                        <!-- Streamer 2 -->
                        <div class="space-y-3">
                            <div class="flex items-center justify-between">
                                <label class="text-sm font-medium text-gray-300">Streamer 2</label>
                                <button id="favoriteBtn2" class="text-gray-400 hover:text-red-500 transition-colors" onclick="toggleFavorite(2)">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.682l-1.318-1.364a4.5 4.5 0 00-6.364 0z"></path>
                                    </svg>
                                </button>
                            </div>
                            <select id="streamer2" class="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all">
                                <option value="">Select Streamer 2</option>
                            </select>
                        </div>
                        
                        <!-- Streamer 3 -->
                        <div class="space-y-3">
                            <div class="flex items-center justify-between">
                                <label class="text-sm font-medium text-gray-300">Streamer 3</label>
                                <button id="favoriteBtn3" class="text-gray-400 hover:text-red-500 transition-colors" onclick="toggleFavorite(3)">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.682l-1.318-1.364a4.5 4.5 0 00-6.364 0z"></path>
                                    </svg>
                                </button>
                            </div>
                            <select id="streamer3" class="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all">
                                <option value="">Select Streamer 3</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Stream Controls -->
                    <div class="flex justify-between items-center">
                        <div class="flex space-x-2">
                            <button id="globalMuteBtn" onclick="toggleGlobalMute()" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition-colors">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.852 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.852l3.531-3.816a1 1 0 011.617.816zM14 5a1 1 0 011.707-.707 5.978 5.978 0 010 8.486A1 1 0 0114 12a4 4 0 000-5.657A1 1 0 0114 5z"></path>
                                </svg>
                            </button>
                            <button id="fullscreenBtn" onclick="toggleMultiStreamFullscreen()" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition-colors">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                                </svg>
                            </button>
                            <!-- Layout presets -->
                            <div class="hidden md:flex items-center gap-1 ml-2">
                                <span class="text-gray-400 text-xs mr-1">Layout:</span>
                                <button class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="setMultiLayout('grid')">Grid</button>
                                <button class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="setMultiLayout('row')">Row</button>
                                <button class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="setMultiLayout('focus1')">Focus 1</button>
                                <button class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="setMultiLayout('focus2')">Focus 2</button>
                                <button class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="setMultiLayout('focus3')">Focus 3</button>
                                <button id="aspectToggleBtn" class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="toggleAspectLock()">Lock 16:9</button>
                                <button class="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-white rounded" onclick="equalizeSplit()">Equal</button>
                                <button class="px-2 py-1 text-xs bg-emerald-600 hover:bg-emerald-700 text-white rounded" onclick="loadMultiStreams()">Load</button>
                        </div>
                        </div>
                    </div>
                </div>
                
            <div id="multiStreamContainer" class="min-h-[280px] bg-gray-900/50 rounded-lg border border-gray-700/50 p-3">
                    <!-- Streams will be loaded here -->
                </div>
            <div id="multiStreamExtras" class="mt-6 hidden">
                <h3 class="text-lg font-semibold text-white mb-2">Stream Stats & Clips</h3>
                <div id="msExtrasGrid" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>
            </div>
        </section>
        </div>

        <!-- Player Stats & Match History Tab Content -->
        <div id="playerStatsTab" class="tab-content">
            <section class="mb-10">
                <h2 class="text-2xl font-bold text-white mb-4">Player Statistics Lookup</h2>
                <p class="text-gray-300 mb-6">Enter a player's name or UID and platform to retrieve their current statistics. Using UID is recommended for consistent lookups.</p>
                
                <form id="playerStatsForm" class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50 space-y-4">
                    <!-- API Selection -->
                    <div class="mb-4">
                        <label class="block text-gray-300 text-sm font-bold mb-2">Choose API Source:</label>
                        <div class="flex items-center space-x-4">
                             <label>
                                <input type="radio" name="apiSource" value="tracker" class="api-source-radio" checked onchange="handleApiSourceChange()">
                                <span class="api-source-label">Tracker.gg</span>
                            </label>
                            <label>
                                <input type="radio" name="apiSource" value="mozambique" class="api-source-radio" onchange="handleApiSourceChange()">
                                <span class="api-source-label">MozambiqueHe.re</span>
                            </label>
                        </div>
                    </div>

                    <div>
                        <label for="playerIdentifier" class="block text-gray-300 text-sm font-bold mb-2">Player Name or UID:</label>
                        <input type="text" id="playerIdentifier" class="shadow appearance-none border border-gray-700 rounded w-full py-2 px-3 bg-gray-900 text-white leading-tight focus:outline-none focus:shadow-outline focus:border-emerald-500" placeholder="e.g., Shroud or 1234567890" required>
                    </div>
                    <div>
                        <label for="platformSelect" class="block text-gray-300 text-sm font-bold mb-2">Platform:</label>
                        <select id="platformSelect" class="shadow appearance-none border border-gray-700 rounded w-full py-2 px-3 bg-gray-900 text-white leading-tight focus:outline-none focus:shadow-outline focus:border-emerald-500" required>
                            <option value="origin" data-mozambique-platform="PC">PC (Origin/Steam)</option>
                            <option value="psn" data-mozambique-platform="PS4">PlayStation (PS4/PS5)</option>
                            <option value="xbl" data-mozambique-platform="X1">Xbox</option>
                        </select>
                    </div>
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center text-gray-300 text-sm">
                            <input type="checkbox" id="useUidCheckbox" class="mr-2 leading-tight" disabled>
                            Use UID instead of Name (MozambiqueHe.re only)
                        </label>
                    </div>
                    <div id="playerStatsMessage" class="text-sm font-medium"></div>
                    <button type="submit" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200">Get Player Stats</button>
                </form>

                <div id="playerStatsResult" class="mt-8">
                    <div id="playerStatsContent" class="text-gray-300">
                        <p>Enter player details and click "Get Player Stats" to see results.</p>
                    </div>
                </div>
                
                <div id="matchHistoryResult" class="mt-8" style="display: none;">
                     <h3 class="text-xl font-bold text-white mb-4">Match History</h3>
                    <div id="matchHistoryContent" class="text-gray-300">
                        <p>Match history will appear here.</p>
                    </div>
                </div>
            </section>
        </div>

        <!-- Favorites Tab Content -->
        <!-- Account Tab Content -->
        <div id="accountTab" class="tab-content">
            <section class="mb-10">
                <h2 class="text-2xl font-bold text-white mb-4">My Account</h2>
                <p class="text-gray-300 mb-6">Manage your account settings, favorite streamers, and preferences in one place.</p>
                
                <!-- Account Overview -->
                <div class="grid md:grid-cols-3 gap-6 mb-8">
                    <!-- Account Info Card -->
                    <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-gradient-to-r from-purple-500 to-emerald-500 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                                </svg>
                    </div>
                            <div class="ml-4">
                                <h3 class="text-lg font-semibold text-white">Account Status</h3>
                                <p id="accountStatusText" class="text-sm text-gray-400">Not signed in</p>
                            </div>
                        </div>
                        <div id="accountActions" class="space-y-3">
                            <button id="changePasswordBtn" onclick="showChangePasswordModal()" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors text-sm" style="display: none;">
                                Change Password
                            </button>
                            <button id="signOutBtn" onclick="signOut()" class="w-full px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors text-sm" style="display: none;">
                                Sign Out
                            </button>
                            <button id="signInBtn" onclick="showAuthModal()" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-colors text-sm">
                                Sign In
                            </button>
                        </div>
                </div>

                    <!-- Quick Stats Card -->
                    <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50">
                        <h3 class="text-lg font-semibold text-white mb-4">Your Stats</h3>
                        <div class="space-y-3">
                            <div class="flex justify-between">
                                <span class="text-gray-400">Favorites:</span>
                                <span id="favoritesCount" class="text-emerald-400 font-medium">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">Account Created:</span>
                                <span id="accountCreated" class="text-blue-400 font-medium">-</span>
                            </div>
                        </div>
                </div>

                    <!-- Preferences Card -->
                    <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50">
                        <h3 class="text-lg font-semibold text-white mb-4">Preferences</h3>
                        <div class="space-y-3">
                            <button onclick="showSettingsModal()" class="w-full px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition-colors text-sm">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                </svg>
                                App Settings
                            </button>
                            <a href="#" onclick="openMultiStreamDock(); return false;" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-colors text-sm block text-center">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                </svg>
                                Multi-Stream
                            </a>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-lg shadow-2xl shadow-black/30 border border-gray-700/50 mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-300">Favorite Streamers</h3>
                        <button onclick="refreshFavorites()" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 text-white font-medium rounded-lg transition-colors duration-200 text-sm">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                            </svg>
                            Refresh Status
                        </button>
                </div>

                    <div id="favoritesLoading" class="text-center py-8" style="display: none;">
                        <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-500"></div>
                        <p class="text-gray-400 mt-2">Loading favorites...</p>
                </div>

                    <div id="favoritesError" class="text-center py-8 text-red-400" style="display: none;">
                        <p>Please sign in to view your favorite streamers.</p>
                        <div class="mt-4">
                            <button onclick="showAuthModal()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded-lg transition-colors duration-200">
                                Sign In
                            </button>
                    </div>
                </div>
                    
                    <div id="favoritesEmpty" class="text-center py-8 text-gray-400" style="display: none;">
                        <svg class="w-16 h-16 mx-auto mb-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.682l-1.318-1.364a4.5 4.5 0 00-6.364 0z"></path>
                        </svg>
                        <h3 class="text-lg font-medium text-gray-300 mb-2">No Favorite Streamers Yet</h3>
                        <p class="mb-4">Add streamers to your favorites by clicking the star icon on the leaderboard.</p>
                        <button onclick="showTab('leaderboardTab')" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 text-white font-medium rounded-lg transition-colors duration-200">
                            Browse Leaderboard
                        </button>
        </div>

                    <div id="favoritesList" class="space-y-4">
                        <!-- Favorites will be populated here -->
                    </div>
                </div>
            </section>
    </div>
        
        </div> <!-- End Main Content Area -->
        </div> <!-- End Main Layout -->

    <div id="stream-preview"><div id="stream-preview-player"></div></div>
    
    <!-- Change Password Modal -->
    <div id="changePasswordModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-white">Change Password</h2>
                <span class="close-button" onclick="hideChangePasswordModal()">&times;</span>
            </div>
            
            <form id="changePasswordForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Current Password</label>
                    <input type="password" id="currentPassword" class="w-full px-3 py-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-purple-500 focus:outline-none" required>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">New Password</label>
                    <input type="password" id="newPassword" class="w-full px-3 py-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-purple-500 focus:outline-none" required minlength="6">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Confirm New Password</label>
                    <input type="password" id="confirmPassword" class="w-full px-3 py-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-purple-500 focus:outline-none" required minlength="6">
                </div>
                <div id="changePasswordError" class="text-red-400 text-sm" style="display: none;"></div>
                <div class="flex gap-3 justify-end pt-4">
                    <button type="button" onclick="hideChangePasswordModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition-colors">
                        Cancel
                    </button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">
                        Update Password
                    </button>
                </div>
            </form>
        </div>
        </div>


    </div> <!-- End Main Content Area -->

    <!-- AI Analysis Modal -->
    <div id="analysisModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="hideModal()">&times;</span>
            <h2 id="modalTitle" class="text-xl font-bold text-white mb-4">Player Performance Analysis</h2>
            <div id="modalContent" class="text-gray-300">
                <div class="spinner"></div>
                <p class="text-center mt-2">Generating analysis...</p>
            </div>
        </div>
    </div>

    <!-- Twitch Override Modal -->
    <div id="overrideModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="hideOverrideModal()">&times;</span>
            <h2 class="text-xl font-bold text-white mb-4">Manage Twitch Override</h2>
            <form id="overrideForm" class="space-y-4">
                <div>
                    <label for="overridePlayerName" class="block text-gray-300 text-sm font-bold mb-2">Player Name (in-game):</label>
                    <input type="text" id="overridePlayerName" class="shadow appearance-none border border-gray-700 rounded w-full py-2 px-3 bg-gray-800 text-white leading-tight focus:outline-none focus:shadow-outline focus:border-indigo-500" placeholder="e.g., Shroud" required>
                </div>
                <div>
                    <label for="overrideTwitchUsername" class="block text-gray-300 text-sm font-bold mb-2">Twitch Username:</label>
                    <input type="text" id="overrideTwitchUsername" class="shadow appearance-none border border-gray-700 rounded w-full py-2 px-3 bg-gray-800 text-white leading-tight focus:outline-none focus:shadow-outline focus:border-indigo-500" placeholder="e.g., shroud" required>
                </div>
                <div id="overrideMessage" class="text-sm font-medium"></div>
                <button type="submit" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200">Submit Override</button>
            </form>
        </div>
    </div>

    <script>
        // Cache-busting: Force reload of updated JavaScript
        console.log('Frontend loaded at:', new Date().toISOString());
        console.log('Version: Updated with debug logs and data fixes');
        // Edge flags default
        window.__edgeFlags = window.__edgeFlags || {
            enable_medal: false,
            max_recent_clips: 4,
            multistream_default_layout: 'equal',
            feature_flags: { multistreamDock: true, streamPage: false }
        };
        // Soft beta gate to buy time for first load
        (function showBetaNoticeOnce(){
            try {
                const KEY = 'beta_notice_v1';
                if (sessionStorage.getItem(KEY)) return;
                sessionStorage.setItem(KEY, '1');
                const overlay = document.createElement('div');
                overlay.id = 'beta-notice';
                overlay.style.position = 'fixed';
                overlay.style.inset = '0';
                overlay.style.background = 'rgba(0,0,0,0.7)';
                overlay.style.zIndex = '10000';
                overlay.innerHTML = `
                  <div style="max-width:640px;margin:10vh auto;background:#111827;border:1px solid #374151;border-radius:12px;color:#e5e7eb;padding:20px;box-shadow:0 20px 40px rgba(0,0,0,0.5)">
                    <h3 style="font-weight:700;font-size:18px;margin:0 0 8px">Beta Notice</h3>
                    <p style="margin:0 0 12px;color:#9ca3af">This site is in active beta. Things may break or load slowly on first visit while data warms up. Thanks for testing!</p>
                    <div style="display:flex;gap:8px;justify-content:flex-end">
                      <button id="beta-continue" style="padding:8px 12px;background:#4b5563;border-radius:8px;color:#fff">Continue</button>
                    </div>
                  </div>`;
                document.body.appendChild(overlay);
                document.getElementById('beta-continue').onclick = () => overlay.remove();
            } catch(e) { /* no-op */ }
        })();
        
        let allPlayers = [];
        let filteredAndSortedPlayers = []; 
        let currentPage = 1;
        const itemsPerPage = 50; 
        let previewTimeout;
        // Use current origin for API calls (works for Vercel deployment)
        const API_BASE_URL = window.location.origin; 
        // API key should be handled server-side via environment variables 
        const MOZAMBIQUE_API_KEY = '456c01cf240c13399563026f5604d777'; 
        const TRACKER_GG_API_KEY = 'c4cc3d18-adaf-487b-b3da-d47b924585c4'; 
        const GEMINI_API_KEY = "AIzaSyA_sdFUk6nrcC8sK3ZlnFbEexJgCTd8SqU"; 
        
        const leaderboardBody = document.getElementById('leaderboard-body');
        const searchInput = document.getElementById('searchInput');
        const liveOnlyToggle = document.getElementById('liveOnlyToggle');
        const streamPreview = document.getElementById('stream-preview');
        const streamPreviewPlayer = document.getElementById('stream-preview-player');
        const predatorThresholdsDiv = document.getElementById('predator-thresholds'); 
        const analysisModal = document.getElementById('analysisModal');
        function addToMultiStream(twitchUser) {
            try {
                // Open the multistream dock and preselect the streamer in the first empty slot
                openMultiStreamDock();
                const slots = ['streamer1','streamer2','streamer3'];
                const empty = slots.map(id => document.getElementById(id)).find(sel => sel && !sel.value);
                if (empty) {
                    // Ensure options are populated
                    const option = Array.from(empty.options).find(o => o.value.toLowerCase() === twitchUser.toLowerCase());
                    if (option) {
                        empty.value = option.value;
                    } else {
                        // If streamer isn't in dropdown (edge case), append it
                        const opt = document.createElement('option');
                        opt.value = twitchUser;
                        opt.textContent = twitchUser;
                        empty.appendChild(opt);
                        empty.value = twitchUser;
                    }
                }
            } catch (e) {
                console.warn('addToMultiStream failed:', e);
                alert('Could not add to Multi-Stream.');
            }
        }

        // Queue for multi-stream: lets the user click multiple "Add" buttons, then confirm
        let pendingMultiStreamQueue = [];
        function queueMultiStreamUser(twitchUser, displayName) {
            if (!twitchUser) return;
            const exists = pendingMultiStreamQueue.some(u => u.toLowerCase() === twitchUser.toLowerCase());
            if (!exists) pendingMultiStreamQueue.push(twitchUser);
            showMultiStreamQueueToast(displayName || twitchUser);
        }

        function showMultiStreamQueueToast(label) {
            let toast = document.getElementById('ms-queue-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'ms-queue-toast';
                toast.style.position = 'fixed';
                toast.style.bottom = '20px';
                toast.style.right = '20px';
                toast.style.zIndex = '9999';
                toast.style.background = 'rgba(31, 41, 55, 0.95)';
                toast.style.border = '1px solid rgba(75,85,99,0.6)';
                toast.style.color = '#e5e7eb';
                toast.style.padding = '12px 14px';
                toast.style.borderRadius = '8px';
                toast.style.boxShadow = '0 10px 20px rgba(0,0,0,0.35)';
                toast.innerHTML = `
                    <div id="ms-queue-text" class="text-sm mb-2">Queued: ${label}</div>
                    <div class="flex gap-2">
                        <button id="ms-queue-view" class="px-3 py-1 bg-purple-600 hover:bg-purple-700 rounded text-white text-xs">Open Queue (${pendingMultiStreamQueue.length})</button>
                        <button id="ms-queue-go" class="px-3 py-1 bg-emerald-600 hover:bg-emerald-700 rounded text-white text-xs">Load Now</button>
                        <button id="ms-queue-clear" class="px-3 py-1 bg-gray-600 hover:bg-gray-700 rounded text-white text-xs">Clear</button>
                    </div>
                `;
                document.body.appendChild(toast);
                document.getElementById('ms-queue-view').onclick = openQueueModal;
                document.getElementById('ms-queue-go').onclick = loadQueueIntoMultistream;
                document.getElementById('ms-queue-clear').onclick = () => { pendingMultiStreamQueue = []; removeQueueToast(); };
            } else {
                const text = document.getElementById('ms-queue-text');
                if (text) text.textContent = `Queued: ${label}`;
                const viewBtn = document.getElementById('ms-queue-view');
                if (viewBtn) viewBtn.textContent = `Open Queue (${pendingMultiStreamQueue.length})`;
            }
        }

        function removeQueueToast() {
            const toast = document.getElementById('ms-queue-toast');
            if (toast && toast.parentNode) toast.parentNode.removeChild(toast);
        }

        function openQueueModal() {
            openMultiStreamDock();
            // Fill dropdowns from queue (non-destructively; existing selection kept)
            const dropdowns = ['streamer1','streamer2','streamer3'].map(id => document.getElementById(id));
            let q = [...pendingMultiStreamQueue];
            dropdowns.forEach(sel => {
                if (!sel) return;
                if (!sel.value && q.length) {
                    const user = q.shift();
                    let opt = Array.from(sel.options).find(o => o.value.toLowerCase() === user.toLowerCase());
                    if (!opt) {
                        opt = document.createElement('option');
                        opt.value = user;
                        opt.textContent = user;
                        sel.appendChild(opt);
                    }
                    sel.value = opt.value;
                }
            });
        }

        function loadQueueIntoMultistream() {
            openQueueModal();
            removeQueueToast();
            loadMultiStreams();
            pendingMultiStreamQueue = [];
        }
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalContent');

        const overrideModal = document.getElementById('overrideModal');
        const overrideForm = document.getElementById('overrideForm');
        const overridePlayerNameInput = document.getElementById('overridePlayerName');
        const overrideTwitchUsernameInput = document.getElementById('overrideTwitchUsername');
        const overrideMessageDiv = document.getElementById('overrideMessage');

        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');
        const pageNumbersDiv = document.getElementById('pageNumbers');

        const playerStatsForm = document.getElementById('playerStatsForm');
        const playerIdentifierInput = document.getElementById('playerIdentifier');
        const platformSelect = document.getElementById('platformSelect');
        const useUidCheckbox = document.getElementById('useUidCheckbox'); 
        const playerStatsMessageDiv = document.getElementById('playerStatsMessage');
        const playerStatsResultDiv = document.getElementById('playerStatsResult');
        const playerStatsContentDiv = document.getElementById('playerStatsContent');
        const matchHistoryResultDiv = document.getElementById('matchHistoryResult'); 
        const matchHistoryContentDiv = document.getElementById('matchHistoryContent'); 

        let rpChart = null;
        let platformChart = null;

        // Supabase auth + favorites
        let supabase = null;
        let supaUser = null;
        let favoritesSet = new Set();

        async function initSupabase() {
            try {
                console.log('Initializing Supabase...', {
                    hasConfig: !!window.__supabaseConfig,
                    hasUrl: !!window.__supabaseConfig?.url,
                    hasAnon: !!window.__supabaseConfig?.anon,
                    hasLib: !!window.supabase
                });
                
                if (window.__supabaseConfig?.url && window.__supabaseConfig?.anon && window.supabase) {
                    // Only create client if it doesn't exist
                    if (!supabase) {
                        supabase = window.supabase.createClient(window.__supabaseConfig.url, window.__supabaseConfig.anon);
                        console.log('Supabase client created');
                    } else {
                        console.log('Supabase client already exists');
                    }
                    
                    const { data, error } = await supabase.auth.getUser();
                    if (error) {
                        console.error('Error getting user:', error);
                    }
                    
                    supaUser = data?.user || null;
                    console.log('Supabase user:', supaUser ? 'logged in' : 'not logged in');
                    
                    if (supaUser) {
                        await loadFavorites();
                    }
                    renderAuthControls();
                    updateAccountDisplay();
                } else {
                    console.warn('Missing Supabase requirements');
                }
            } catch (e) {
                console.error('Supabase init error:', e);
            }
        }

        function renderAuthControls() {
            const container = document.getElementById('authControls');
            const accountBtn = document.getElementById('accountButton');
            const accountStatus = document.getElementById('accountStatus');
            if (supaUser) {
                if (container) container.innerHTML = `<span class="text-xs text-gray-400 mr-2">${supaUser.email || 'Signed in'}</span>`;
                if (accountStatus) accountStatus.textContent = 'Sign out';
                if (accountBtn) accountBtn.onclick = async () => {
                    await supabase.auth.signOut();
                    supaUser = null;
                    favoritesSet.clear();
                    renderAuthControls();
                    updateLeaderboardAndPagination();
                };
            } else {
                if (container) container.innerHTML = '';
                if (accountStatus) accountStatus.textContent = 'Sign in';
                if (accountBtn) accountBtn.onclick = () => showEmailLoginModal();
            }
        }

        function showEmailLoginModal() {
            const modal = document.getElementById('authModal');
            const emailInput = document.getElementById('loginEmail');
            const sendBtn = document.getElementById('loginSendBtn');
            const cancelBtn = document.getElementById('loginCancelBtn');
            const msg = document.getElementById('emailSentMsg');
            const pwSection = document.getElementById('authPasswordSection');
            const linkSection = document.getElementById('authEmailLinkSection');
            const googleSection = document.getElementById('authGoogleSection');
            // Default layout: password section visible, providers below
            pwSection.classList.remove('hidden');
            linkSection.classList.add('hidden');
            googleSection.classList.add('hidden');
            msg.classList.add('hidden');
            emailInput.value = '';
            modal.classList.remove('hidden');
            modal.classList.add('flex');

            const close = () => { modal.classList.add('hidden'); modal.classList.remove('flex'); };
            cancelBtn.onclick = close;
            sendBtn.onclick = async () => {
                const email = emailInput.value.trim();
                if (!email) return;
                const redirectTo = window.location.href.split('#')[0];
                await supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: redirectTo } });
                msg.classList.remove('hidden');
                setTimeout(close, 2000);
            };

            // Tab buttons (we keep tabs hidden; default is password layout).
            const twitchSection = document.getElementById('authTwitchSection');
            const tabs = document.getElementById('authTabs');
            tabs.classList.add('hidden');

            // Password auth events
            document.getElementById('pwCancelBtn').onclick = close;
            let isSignup = false;
            document.getElementById('pwSignupToggle').onclick = () => {
                isSignup = !isSignup;
                const btn = document.getElementById('pwSignupToggle');
                btn.textContent = isSignup ? 'Back to sign in' : 'Sign up';
                const primary = document.getElementById('pwSubmitBtn');
                primary.textContent = isSignup ? 'Create account' : 'Sign in';
            };

            document.getElementById('pwSubmitBtn').onclick = async () => {
                const email = document.getElementById('pwEmail').value.trim();
                const password = document.getElementById('pwPassword').value;
                const msgEl = document.getElementById('pwMsg');
                msgEl.classList.add('hidden');
                try {
                    if (isSignup) {
                        const { error } = await supabase.auth.signUp({
                            email,
                            password,
                            options: { emailRedirectTo: window.location.href.split('#')[0] }
                        });
                        if (error) throw error;
                        msgEl.textContent = 'Check your email to confirm your account.';
                    } else {
                        const { error } = await supabase.auth.signInWithPassword({ email, password });
                        if (error) throw error;
                        close();
                        await initSupabase();
                        return;
                    }
                    msgEl.classList.remove('hidden');
                } catch (e) {
                    msgEl.textContent = e.message || 'Error';
                    msgEl.classList.remove('hidden');
                }
            };

            // Password reset
            document.getElementById('pwResetBtn').onclick = async () => {
                const email = document.getElementById('pwEmail').value.trim();
                if (!email) return;
                await supabase.auth.resetPasswordForEmail(email, { redirectTo: window.location.href.split('#')[0] });
                const msgEl = document.getElementById('pwMsg');
                msgEl.textContent = 'Password reset email sent.';
                msgEl.classList.remove('hidden');
            };

            // Google OAuth
            document.getElementById('googleCancelBtn').onclick = close;
            document.getElementById('googleSignInBtn').onclick = async () => {
                await supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: window.location.href.split('#')[0] } });
            };
            // GitHub removed

            // Twitch OAuth (if enabled in Supabase)
            document.getElementById('twitchCancelBtn').onclick = close;
            document.getElementById('twitchSignInBtn').onclick = async () => {
                await supabase.auth.signInWithOAuth({ provider: 'twitch', options: { redirectTo: window.location.href.split('#')[0] } });
            };
        }

        async function loadFavorites() {
            console.log('Loading favorites...', { supabase: !!supabase, supaUser: !!supaUser });
            favoritesSet.clear();
            if (!supabase || !supaUser) {
                console.log('Cannot load favorites - no supabase or user');
                return;
            }
            const { data, error } = await supabase.from('favorites')
                .select('twitch_username')
                .eq('user_id', supaUser.id);
            console.log('Favorites query result:', { data, error });
            if (error) {
                console.error('Error loading favorites:', error);
            } else if (Array.isArray(data)) {
                data.forEach(r => favoritesSet.add(String(r.twitch_username).toLowerCase()));
                console.log('Loaded favorites:', Array.from(favoritesSet));
            }
        }

        async function toggleFavorite(twitchUsername) {
            console.log('Toggle favorite:', twitchUsername);
            if (!supabase) {
                console.error('No Supabase client');
                return;
            }
            if (!supaUser) {
                alert('Please sign in to save favorites.');
                return;
            }
            const key = String(twitchUsername).toLowerCase();
            try {
                if (favoritesSet.has(key)) {
                    const { error } = await supabase.from('favorites').delete().eq('twitch_username', key).eq('user_id', supaUser.id);
                    if (error) {
                        console.error('Error removing favorite:', error);
                        alert('Failed to remove favorite. Check console for details.');
                    } else {
                        favoritesSet.delete(key);
                        console.log('Removed favorite:', key);
                    }
                } else {
                    const { data, error } = await supabase.from('favorites').insert({ 
                        twitch_username: key,
                        user_id: supaUser.id 
                    }).select();
                    if (error) {
                        console.error('Error adding favorite:', error);
                        alert(`Failed to add favorite: ${error.message}`);
                    } else {
                        favoritesSet.add(key);
                        console.log('Added favorite:', key, 'Response:', data);
                        // Verify it was saved
                        const { data: checkData, error: checkError } = await supabase
                            .from('favorites')
                            .select('*')
                            .eq('user_id', supaUser.id);
                        console.log('Verification check - all user favorites:', checkData, 'Error:', checkError);
                    }
                }
                updateLeaderboardAndPagination();
            } catch (e) {
                console.error('Exception in toggleFavorite:', e);
            }
        }

        const showTab = (tabId) => {
            try {
                // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                const tabElement = document.getElementById(tabId);
                if (tabElement) {
                    tabElement.classList.add('active');
                }
                
                // Update navigation active states
                document.querySelectorAll('.nav-item').forEach(button => button.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
                
                // Set active state for nav-item
                const navElement = document.querySelector(`.nav-item[onclick="showTab('${tabId}')"]`);
                if (navElement) {
                    navElement.classList.add('active');
                }
                
                // Fallback for old tab-button elements
                const buttonElement = document.querySelector(`.tab-button[onclick="showTab('${tabId}')"]`);
                if (buttonElement) {
                    buttonElement.classList.add('active');
                }
            } catch (error) {
                console.error('Error in showTab:', error);
            }
        };

        const showModal = (title, contentHtml) => {
            modalTitle.textContent = title;
            modalContent.innerHTML = contentHtml;
            analysisModal.classList.add('show');
        };

        const hideModal = () => {
            analysisModal.classList.remove('show');
            modalContent.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Generating analysis...</p>';
        };

        const showOverrideModal = () => {
            overrideModal.classList.add('show');
            overrideMessageDiv.textContent = ''; 
            overridePlayerNameInput.value = ''; 
            overrideTwitchUsernameInput.value = '';
        };

        const hideOverrideModal = () => {
            overrideModal.classList.remove('show');
        };

        window.onclick = (event) => {
            if (event.target == analysisModal) hideModal();
            if (event.target == overrideModal) hideOverrideModal(); 
        };

        const getChangeHtml = (change) => {
            const num = parseInt(String(change).replace(/,/g, ''), 10);
            if (num > 0) return `<span class="flex items-center text-green-400"><svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>${num.toLocaleString()}</span>`;
            if (num < 0) return `<span class="flex items-center text-red-400"><svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>${Math.abs(num).toLocaleString()}</span>`;
            return `<span class="text-gray-500">${num}</span>`;
        };

        const getStatusHtml = (status, twitchLink, vodsEnabled, recentVideos, hasClips, recentClips) => {
            const s = String(status).toLowerCase();
            let html = '';
            
            if (s.includes('live')) {
                // Extract username from Twitch link for rewind functionality
                const username = twitchLink ? twitchLink.split('twitch.tv/')[1]?.split('?')[0]?.split('/')[0] : null;
                html = `<div class="flex items-center space-x-2">
                    <a href="${twitchLink}" target="_blank" class="animate-live-pulse bg-red-600 text-white text-xs font-semibold px-2.5 py-0.5 rounded-full w-fit">LIVE</a>
                    
                </div>`;
            } else if (s.includes('match')) {
                html = `<span class="bg-purple-600 text-white text-xs font-semibold px-2.5 py-0.5 rounded-full w-fit">IN-MATCH</span>`;
            } else if (s.includes('offline - has twitch')) {
                html = `<span class="bg-gray-600 text-white text-xs font-semibold px-2.5 py-0.5 rounded-full w-fit">OFFLINE</span>`;
            } else {
                html = `<span class="text-gray-400">${status || 'Offline'}</span>`;
            }
            if (vodsEnabled && recentVideos && recentVideos.length > 0) {
                const latestVideo = recentVideos[0];
                const videoDate = new Date(latestVideo.created_at);
                const timeAgo = getTimeAgo(videoDate);
                html += `<div class="flex items-center mt-1">
                    <span class="bg-green-600 text-white text-xs font-semibold px-2 py-0.5 rounded-full mr-2">VODs</span>
                    <span class="text-xs text-gray-500">Latest: ${timeAgo}</span>
                    <a href="${latestVideo.url}" target="_blank" class="ml-2 text-xs text-blue-400 hover:text-blue-300 transition-colors" title="Watch latest VOD">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </a>
                </div>`;
            } else if (vodsEnabled === false) {
                html += `<div class="flex items-center mt-1">
                    <span class="text-xs text-gray-500">No VODs available</span>
                </div>`;
            }
            if (hasClips && recentClips && recentClips.length > 0) {
                const latestClip = recentClips[0];
                const clipDate = new Date(latestClip.created_at);
                const timeAgo = getTimeAgo(clipDate);
                html += `<div class="flex items-center mt-1">
                    <span class="bg-orange-600 text-white text-xs font-semibold px-2 py-0.5 rounded-full mr-2">Clips</span>
                    <span class="text-xs text-gray-500">Latest: ${timeAgo}</span>
                    <a href="${latestClip.url}" target="_blank" class="ml-2 text-xs text-orange-400 hover:text-orange-300 transition-colors" title="Watch latest clip">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </a>
                </div>`;
            }
            if (twitchLink) html += `<a href="${twitchLink}" target="_blank" class="inline-block ml-2 text-gray-500 hover:text-purple-400 transition-colors" title="Visit Twitch channel"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="currentColor" viewBox="0 0 24 24"><path d="M11.571 4.714h1.715v5.143H11.57zm4.714 0h1.715v5.143h-1.715zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0H6zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714v9.429z"/></svg></a>`;
            return `<div class="flex flex-col">${html}</div>`;
        };

        // Add helper function to format time ago
        const getTimeAgo = (date) => {
            const now = new Date();
            const diffInSeconds = Math.floor((now - date) / 1000);
            
            if (diffInSeconds < 60) return 'just now';
            if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
            if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
            if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
            if (diffInSeconds < 31536000) return `${Math.floor(diffInSeconds / 2592000)}mo ago`;
            return `${Math.floor(diffInSeconds / 31536000)}y ago`;
        };
        
        const getStreamHtml = (stream) => {
            if (stream) {
                if (stream.viewers > 0) {
                    // Live streamer
                    return `<div class="flex flex-col"><span class="font-semibold text-white">${stream.viewers.toLocaleString()} viewers</span><span class="text-xs text-gray-400">${stream.game || 'Streaming'}</span></div>`;
                } else if (stream.game === 'Offline') {
                    // Offline user with valid Twitch account
                    return `<div class="flex flex-col"><span class="font-semibold text-gray-400">0 viewers</span><span class="text-xs text-gray-500">Has Twitch Account</span></div>`;
                }
            }
            return `<span class="text-gray-600">-</span>`;
        };

        const getLegendHtml = (currentLegend, playerName) => {
            if (currentLegend && currentLegend.name) {
                const imageUrl = currentLegend.image || 'https://cdn.apexlegendsstatus.com/legends/unknown.png';
                return `<div class="flex items-center space-x-2">
                    <img src="${imageUrl}" alt="${currentLegend.name}" class="w-8 h-8 rounded-full object-cover border border-purple-400" 
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="w-8 h-8 bg-purple-600 rounded-full flex items-center justify-center text-white text-xs font-bold border border-purple-400" style="display:none;">
                        ${currentLegend.name.charAt(0)}
                    </div>
                    <div class="flex flex-col">
                        <span class="font-semibold text-purple-400 text-sm">${currentLegend.name}</span>
                        <span class="text-xs text-gray-500">Current</span>
                    </div>
                </div>`;
            } else if (currentLegend === 'loading') {
                return `<div class="flex items-center space-x-2">
                    <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-purple-500"></div>
                    <span class="text-xs text-gray-400">Loading legend...</span>
                </div>`;
            }
            return `<button onclick="fetchPlayerLegend('${playerName}')" class="bg-purple-600 hover:bg-purple-700 text-white text-xs px-3 py-1 rounded-full transition-colors">
                Show Legend
            </button>`;
        };

        // Persistent 2-hour legend cache
        const LEGEND_CACHE_DURATION = 2 * 60 * 60 * 1000; // 2 hours in milliseconds
        const LEGEND_CACHE_KEY = 'apex_legend_cache';
        
        // API rate limiting - max 2 requests per second
        let lastApiCall = 0;
        const MIN_API_INTERVAL = 500; // 500ms between calls (2/second)
        const apiQueue = [];
        let isProcessingQueue = false;

        const getLegendCache = () => {
            try {
                const cached = localStorage.getItem(LEGEND_CACHE_KEY);
                if (cached) {
                    const data = JSON.parse(cached);
                    // Clean expired entries
                    const now = Date.now();
                    const cleaned = {};
                    for (const [player, entry] of Object.entries(data)) {
                        if (now - entry.timestamp < LEGEND_CACHE_DURATION) {
                            cleaned[player] = entry;
                        }
                    }
                    // Save cleaned cache
                    localStorage.setItem(LEGEND_CACHE_KEY, JSON.stringify(cleaned));
                    return cleaned;
                }
            } catch (e) {
                console.warn('Error reading legend cache:', e);
            }
            return {};
        };

        const setLegendCache = (playerName, legendData) => {
            try {
                const cache = getLegendCache();
                cache[playerName.toLowerCase()] = {
                    data: legendData,
                    timestamp: Date.now()
                };
                localStorage.setItem(LEGEND_CACHE_KEY, JSON.stringify(cache));
                console.log(`Cached legend for ${playerName} (expires in 2h)`);
            } catch (e) {
                console.warn('Error saving legend cache:', e);
            }
        };

        const getCachedLegend = (playerName) => {
            const cache = getLegendCache();
            const entry = cache[playerName.toLowerCase()];
            if (entry && (Date.now() - entry.timestamp < LEGEND_CACHE_DURATION)) {
                console.log(`Using 2h cached legend for ${playerName}`);
                return entry.data;
            }
            return null;
        };

        const getCurrentPagePlayers = () => {
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            return filteredAndSortedPlayers.slice(startIndex, endIndex);
        };

        // Rate-limited API call processor
        const processApiQueue = async () => {
            if (isProcessingQueue || apiQueue.length === 0) return;
            
            isProcessingQueue = true;
            while (apiQueue.length > 0) {
                const { playerName, resolve, reject } = apiQueue.shift();
                
                // Respect rate limit
                const now = Date.now();
                const timeSinceLastCall = now - lastApiCall;
                if (timeSinceLastCall < MIN_API_INTERVAL) {
                    await new Promise(resolve => setTimeout(resolve, MIN_API_INTERVAL - timeSinceLastCall));
                }
                
                try {
                    const result = await fetchPlayerLegendImmediate(playerName);
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
                
                lastApiCall = Date.now();
            }
            isProcessingQueue = false;
        };

        // Immediate API call (bypasses queue - used internally)
        const fetchPlayerLegendImmediate = async (playerName) => {
            try {
                const mozambiqueApiUrl = `https://api.mozambiquehe.re/bridge?auth=${MOZAMBIQUE_API_KEY}&platform=PC&player=${encodeURIComponent(playerName)}`;
                console.log(`Making rate-limited API call for: ${playerName}`);
                
                const response = await fetch(mozambiqueApiUrl);
                const data = await response.json();

                let legendData = null;
                if (data && data.legends && data.legends.selected) {
                    const selected = data.legends.selected;
                    
                    // Try multiple image sources
                    let imageUrl = selected.ImgAssets?.banner || 
                                  selected.ImgAssets?.icon || 
                                  selected.ImgAssets?.portrait ||
                                  `https://cdn.trackercdn.com/cdn/tracker.gg/apex-legends/legends/${selected.LegendName?.toLowerCase().replace(/\s+/g, '-')}.png`;
                    
                    legendData = {
                        name: selected.LegendName,
                        image: imageUrl
                    };
                }

                // Cache for 2 hours
                setLegendCache(playerName, legendData);
                return legendData;
            } catch (error) {
                console.error(`API call failed for ${playerName}:`, error);
                setLegendCache(playerName, null); // Cache failures too
                throw error;
            }
        };

        const fetchPlayerLegend = async (playerName) => {
            console.log(`Requesting legend for: ${playerName}`);
            
            // Check 2-hour cache first
            const cached = getCachedLegend(playerName);
            if (cached !== null) {
                // Update UI immediately with cached data
                const player = filteredAndSortedPlayers.find(p => p.name === playerName);
                if (player) {
                    player.current_legend = cached;
                    renderLeaderboard(getCurrentPagePlayers());
                }
                return cached;
            }

            // Find player and show loading state
            const player = filteredAndSortedPlayers.find(p => p.name === playerName);
            if (player) {
                player.current_legend = 'loading';
                renderLeaderboard(getCurrentPagePlayers());
            }

            // Add to rate-limited queue
            return new Promise((resolve, reject) => {
                apiQueue.push({ playerName, resolve, reject });
                processApiQueue().then(() => {
                    // Update UI with result
                    const cachedResult = getCachedLegend(playerName);
                    if (player) {
                        player.current_legend = cachedResult;
                        renderLeaderboard(getCurrentPagePlayers());
                    }
                });
            });
        };

        // Check if player legends are cached and show them immediately
        const loadCachedLegends = () => {
            const currentPlayers = getCurrentPagePlayers();
            let updatedAny = false;
            
            for (const player of currentPlayers) {
                if (!player.current_legend) {
                    const cached = getCachedLegend(player.name);
                    if (cached !== null) {
                        player.current_legend = cached;
                        updatedAny = true;
                        console.log(`Loaded cached legend for ${player.name}: ${cached?.name || 'none'}`);
                    }
                }
            }
            
            if (updatedAny) {
                renderLeaderboard(currentPlayers);
            }
        };

        // Automatically load legends for top players (respects 2h cache and rate limits)
        const loadTopPlayerLegends = async () => {
            // First, load any cached legends immediately
            loadCachedLegends();
            
            const topPlayers = filteredAndSortedPlayers.slice(0, 6); // Reduced to 6 for rate limiting
            console.log(`Checking legends for top ${topPlayers.length} players:`, topPlayers.map(p => p.name));
            
            // Only fetch uncached legends
            const uncachedPlayers = topPlayers.filter(player => {
                const cached = getCachedLegend(player.name);
                return cached === null; // null means not cached (undefined means no legend found)
            });
            
            if (uncachedPlayers.length === 0) {
                console.log('All top players have cached legends');
                return;
            }
            
            console.log(`Need to fetch legends for ${uncachedPlayers.length} players:`, uncachedPlayers.map(p => p.name));
            
            // Add small delay between requests to respect rate limits
            for (let i = 0; i < uncachedPlayers.length; i++) {
                const player = uncachedPlayers[i];
                setTimeout(async () => {
                    console.log(`Auto-loading legend for: ${player.name}`);
                    await fetchPlayerLegend(player.name);
                }, i * 600); // 600ms delay for safety
            }
        };
        
        const renderLeaderboard = (playersToRender) => { 
            leaderboardBody.innerHTML = ''; 
            if (!Array.isArray(playersToRender) || playersToRender.length === 0) {
                leaderboardBody.innerHTML = `<tr><td colspan="9" class="px-6 py-4 text-center text-gray-500">No players found.</td></tr>`; 
                return;
            }
            playersToRender.forEach(player => {
                const row = document.createElement('tr');
                row.className = 'border-b border-gray-700/50 hover:bg-gray-700/30 transition-colors duration-200';
                const flagHtml = player.country_code ? `<span class="inline-block mr-2 align-middle"><img src="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/6.6.6/flags/4x3/${player.country_code}.svg" alt="${player.country_code}" class="h-4 rounded-sm"/></span>` : '';
                const inputIcon = player.input_device === 'controller' ? '<svg class="w-4 h-4 text-gray-400 ml-1" viewBox="0 0 24 24" fill="currentColor"><path d="M6 7h12a4 4 0 014 4v5a3 3 0 01-3 3h-1a3 3 0 01-2.12-.88L14 16h-4l-1.88 2.12A3 3 0 016 19H5a3 3 0 01-3-3v-5a4 4 0 014-4zM8 11H6v2h2v2h2v-2h2v-2h-2V9H8v2z"/></svg>' : (player.input_device === 'kbm' ? '<svg class="w-4 h-4 text-gray-400 ml-1" viewBox="0 0 24 24" fill="currentColor"><path d="M4 5h16a2 2 0 012 2v6H2V7a2 2 0 012-2zm0 10h4v4H4v-4zm6 0h4v4h-4v-4zm6 0h4v4h-4v-4zM6 8h2v2H6V8zm4 0h2v2h-2V8zm4 0h2v2h-2V8z"/></svg>' : '');
                const playerNameHtml = player.twitchLink ? `<a href="${player.twitchLink}" target="_blank" class="hover:text-emerald-400 transition-colors">${player.name}</a>` : player.name;
                const favKey = (player.canonical_twitch_username || '').toLowerCase();
                const isFav = favoritesSet.has(favKey);
                const favBtn = `<button class="ml-2" title="Favorite" onclick="toggleFavorite('${favKey}')">${isFav ? '' : ''}</button>`;
                const legendHtml = getLegendHtml(player.current_legend, player.name);
                // Debug first few players
                if (player.rank <= 3) {
                    console.log(`Rendering player ${player.name} (rank ${player.rank}) with legend:`, player.current_legend, 'HTML:', legendHtml);
                }
                row.innerHTML = `
                    <td class="px-6 py-4 font-medium text-gray-200">#${player.rank}</td>
                    <td class="px-6 py-4 font-bold text-white flex items-center">${flagHtml}${playerNameHtml}${favBtn}${inputIcon}</td>
                    <td class="px-6 py-4">${legendHtml}</td>
                    <td class="px-6 py-4 font-semibold text-emerald-400">${player.rp.toLocaleString()}</td>
                    <td class="px-6 py-4">${getChangeHtml(player.change)}</td>
                    <td class="px-6 py-4">${player.level.toLocaleString()}</td>
                    <td class="px-6 py-4">${getStatusHtml(player.status, player.twitchLink, player.vods_enabled, player.recent_videos, player.hasClips, player.recentClips)}</td>
                    <td class="px-6 py-4">${getStreamHtml(player.stream)}</td>
                    <td class="px-6 py-4">
                        ${(() => { 
                            const live = String(player.status).toLowerCase() === 'live';
                            const user = player.stream?.twitchUser || (player.twitchLink ? extractUsernameFromLink(player.twitchLink) : '');
                            if (!live || !user) return '<span class="text-gray-500 text-xs"></span>';
                            const safeName = (player.name || '').replace(/"/g, '&quot;');
                            return `<button onclick=\"queueMultiStreamUser('${user}','${safeName}')\" class=\"bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded-full text-xs transition-colors duration-200\">Add to Multi-Stream</button>`;
                        })()}
                    </td>
                `;
                row.addEventListener('mouseenter', (event) => handleMouseEnter(event, player));
                row.addEventListener('mouseleave', handleMouseLeave);
                row.addEventListener('mousemove', handleMouseMove);
                leaderboardBody.appendChild(row);
            });
        };

        const handleMouseEnter = (event, player) => {
            clearTimeout(previewTimeout);
            // Check for live status and either stream object or twitch_link
            const twitchUsername = player.stream?.twitchUser || (player.twitch_link ? extractUsernameFromLink(player.twitch_link) : null);
            
            if (player.status === 'Live' && twitchUsername) {
                previewTimeout = setTimeout(() => showStreamPreview(twitchUsername), 300); 
            }
        };

        const handleMouseLeave = () => { 
            clearTimeout(previewTimeout); 
            hideStreamPreview(); 
        };

        const handleMouseMove = (event) => {
            const offsetX = 20, offsetY = 20;
            let top = event.clientY + offsetY, left = event.clientX + offsetX;
            if (top + streamPreview.offsetHeight > window.innerHeight) top = event.clientY - streamPreview.offsetHeight - offsetY;
            if (left + streamPreview.offsetWidth > window.innerWidth) left = event.clientX - streamPreview.offsetWidth - offsetX;
            streamPreview.style.top = `${top}px`;
            streamPreview.style.left = `${left}px`;
        };

        const showStreamPreview = (twitchUser) => {
            streamPreviewPlayer.innerHTML = ''; 
            new Twitch.Embed(streamPreviewPlayer, {
                width: "100%", height: "100%", channel: twitchUser,
                layout: "video", muted: false, autoplay: true, parent: [window.location.hostname],
                volume: 0.5
            });
            
            // Try to unmute after a short delay
            setTimeout(() => {
                const iframe = streamPreviewPlayer.querySelector('iframe');
                if (iframe) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'setVolume',
                            volume: 0.5
                        }, '*');
                    } catch (e) {
                        console.log('Could not set volume via postMessage');
                    }
                }
            }, 1000);
            
            streamPreview.style.opacity = '1';
            streamPreview.style.transform = 'scale(1)';
        };

        const hideStreamPreview = () => {
            streamPreview.style.opacity = '0';
            streamPreview.style.transform = 'scale(0.95)';
            setTimeout(() => { streamPreviewPlayer.innerHTML = ''; }, 200);
        };

        const applyFilters = () => {
            const searchTerm = searchInput.value.toLowerCase();
            const liveOnly = liveOnlyToggle.checked;
            
            filteredAndSortedPlayers = allPlayers;

            if (liveOnly) filteredAndSortedPlayers = filteredAndSortedPlayers.filter(p => String(p.status).toLowerCase() === 'live');
            if (searchTerm) filteredAndSortedPlayers = filteredAndSortedPlayers.filter(p => String(p.name).toLowerCase().includes(searchTerm));
            
            currentPage = 1; 
            updateLeaderboardAndPagination();
            
            // Also refresh favorites if on that tab
            const favoritesTab = document.getElementById('favoritesTab');
            if (favoritesTab && favoritesTab.classList.contains('active')) {
                refreshFavorites();
            }
        };

        function renderPredatorThresholds(data) {
            console.log('Rendering predator thresholds with data:', data);
            predatorThresholdsDiv.innerHTML = '';
            const platformOrder = { PC: 'PC', PlayStation: 'PlayStation', Xbox: 'Xbox', Switch: 'Switch' };
            const platformColors = {
                PC: 'border-blue-700/50', PlayStation: 'border-blue-700/50',
                Xbox: 'border-green-700/50', Switch: 'border-red-700/50'
            };

            for (const key in platformOrder) {
                const platformData = data[key];
                console.log(`Platform ${key} data:`, platformData);
                const card = document.createElement('div');
                card.className = `p-5 rounded-xl shadow-2xl shadow-black/30 border ${platformColors[key] || 'border-gray-700/50'} bg-gray-800/50 backdrop-blur-sm`;
                if (platformData) {
                    let totalMastersAndPreds = platformData.total_masters_and_preds || 0;
                    let mastersPredsDisplay = `${totalMastersAndPreds.toLocaleString()} Masters & Preds`;

                    card.innerHTML = `
                        <h3 class="font-semibold text-gray-300">${platformOrder[key]}</h3>
                        <p class="text-3xl font-bold text-white my-1">${platformData.predator_rp.toLocaleString()} RP</p>
                        <p class="text-xs text-gray-400">Predator Threshold</p>
                        <div class="text-sm mt-2 font-medium">${getChangeHtml(platformData.rp_change_24h)} in 24h</div>
                        <p class="text-sm text-gray-400 mt-1">${mastersPredsDisplay}</p>
                    `;
                } else {
                    card.innerHTML = `<h3 class="font-semibold text-gray-300">${platformOrder[key]}</h3><p class="text-sm mt-2">Data not available</p>`;
                }
                predatorThresholdsDiv.appendChild(card);
            }
        }

        function renderRpDistributionChart(players) {
            const ctx = document.getElementById('rpDistributionChart').getContext('2d');
            const topPlayers = players.slice(0, 20);
            
            if (rpChart) rpChart.destroy();

            rpChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topPlayers.map(p => p.name),
                    datasets: [{
                        label: 'Player RP',
                        data: topPlayers.map(p => p.rp),
                        backgroundColor: 'rgba(52, 211, 153, 0.6)', 
                        borderColor: 'rgba(5, 150, 105, 1)', 
                        borderWidth: 1
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    scales: {
                        y: { 
                            beginAtZero: false,
                            ticks: { color: '#e5e7eb' }, 
                            grid: { color: 'rgba(255, 255, 255, 0.1)' } 
                        },
                        x: { 
                            ticks: { 
                                color: '#e5e7eb', 
                                callback: function(value) {
                                    const label = this.getLabelForValue(value);
                                    return label.length > 16 ? label.substring(0, 16) + '...' : label;
                                }
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' } 
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += context.parsed.y.toLocaleString() + ' RP';
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderPlatformDistributionChart(data) {
            const ctx = document.getElementById('platformDistributionChart').getContext('2d');
            const platformData = Object.values(data).filter(p => p.masters_count);
            
            if (platformChart) platformChart.destroy();

            platformChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['PC', 'PlayStation', 'Xbox', 'Switch'],
                    datasets: [{
                        label: 'Masters & Predators',
                        data: [data.PC?.masters_count || 0, data.PS4?.masters_count || 0, data.X1?.masters_count || 0, data.SWITCH?.masters_count || 0],
                        backgroundColor: ['#3b82f6', '#2563eb', '#1e813a', '#ef4444'], 
                        hoverOffset: 4
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    plugins: { 
                        legend: { 
                            position: 'top',
                            labels: { color: '#e5e7eb' } 
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed !== null) label += context.parsed.toLocaleString() + ' Masters/Preds';
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        async function analyzePlayerPerformance(playerName, playerRp, rpChange24h, playerLevel) {
            showModal(`Analyzing ${playerName}'s Performance`, '<div class="spinner"></div><p class="text-center mt-2">Generating analysis...</p>');
            const prompt = `As an Apex Legends coach, provide **3-4 concise, actionable bullet points** of feedback for player ${playerName}. Their current RP is ${playerRp}, 24-hour RP change: ${rpChange24h}, Level: ${playerLevel}. Focus on clear strengths and 1-2 key areas for improvement. Use a direct, encouraging tone. Very brief, max 70 words.`;
            
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Gemini API error: ${response.status}`);
                
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    modalContent.innerHTML = `<p class="text-gray-300">${result.candidates[0].content.parts[0].text}</p>`;
                } else {
                    throw new Error("Invalid response structure from AI.");
                }
            } catch (error) {
                modalContent.innerHTML = `<p class="text-red-500">Error generating analysis: ${error.message}</p>`;
                console.error("Error calling Gemini API:", error);
            }
        }

        async function getLegendTips(legendName) {
            showModal(`Insights for ${legendName} `, '<div class="spinner"></div><p class="text-center mt-2">Fetching legend insights...</p>');
            const prompt = `Give me a **very brief lore bite** for ${legendName} from Apex Legends, then **3-4 super concise tactical tips** (bullet points) on using their abilities effectively. Max 60 words. Think quick, actionable advice.`;
            
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Gemini API error: ${response.status}`);
                
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    modalContent.innerHTML = `<p class="text-gray-300">${result.candidates[0].content.parts[0].text}</p>`;
                } else {
                    throw new Error("Invalid response structure from AI.");
                }
            } catch (error) {
                modalContent.innerHTML = `<p class="text-red-500">Error fetching legend insights: ${error.message}</p>`;
                console.error("Error calling Gemini API for legend tips:", error);
            }
        }


        async function submitTwitchOverride(event) {
            event.preventDefault(); 
            overrideMessageDiv.textContent = 'Submitting...';
            overrideMessageDiv.className = 'text-sm font-medium text-gray-400';

            const playerName = overridePlayerNameInput.value.trim();
            const twitchUsername = overrideTwitchUsernameInput.value.trim();

            if (!playerName || !twitchUsername) {
                overrideMessageDiv.textContent = 'Player Name and Twitch Username are required.';
                overrideMessageDiv.className = 'text-sm font-medium text-red-500';
                return;
            }

            const overrideApiUrl = `${API_BASE_URL}/api/stream-override`;
            try {
                                const response = await fetch(overrideApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ player_name: playerName, twitch_username: twitchUsername })
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    overrideMessageDiv.textContent = `Override for ${playerName} added/updated successfully!`;
                    overrideMessageDiv.className = 'text-sm font-medium text-green-500';
                    setTimeout(() => {
                        hideOverrideModal();
                        initializeApp(); 
                    }, 1500);
                } else {
                    throw new Error(result.message || 'Failed to submit override.');
                }
            } catch (error) {
                overrideMessageDiv.textContent = `Error: ${error.message}`;
                overrideMessageDiv.className = 'text-sm font-medium text-red-500';
                console.error('Error submitting Twitch override:', error);
            }
        }

        // Function to handle API source change (Tracker.gg vs MozambiqueHe.re)
        const handleApiSourceChange = () => {
            const selectedApi = document.querySelector('input[name="apiSource"]:checked').value;
            const switchOption = platformSelect.querySelector('option[value="switch"]');
            
            if (selectedApi === 'mozambique') {
                useUidCheckbox.disabled = false;
                if (!switchOption) {
                    const newSwitchOption = document.createElement('option');
                    newSwitchOption.value = 'switch';
                    newSwitchOption.setAttribute('data-mozambique-platform', 'SWITCH');
                    newSwitchOption.textContent = 'Nintendo Switch (Mozambique only)';
                    platformSelect.appendChild(newSwitchOption);
                }
            } else { // Tracker.gg selected
                useUidCheckbox.disabled = true;
                useUidCheckbox.checked = false;
                if (platformSelect.value === 'switch') {
                    platformSelect.value = 'origin'; // Default back to PC if Switch was selected
                }
                if (switchOption) {
                    platformSelect.removeChild(switchOption);
                }
            }
        };


        async function fetchPlayerStats(event) {
            event.preventDefault();
            playerStatsMessageDiv.textContent = '';
            playerStatsContentDiv.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Fetching player data...</p>';
            matchHistoryContentDiv.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Fetching match history...</p>';
            matchHistoryResultDiv.style.display = 'none'; 

            const identifier = playerIdentifierInput.value.trim();
            const selectedApi = document.querySelector('input[name="apiSource"]:checked').value;
            let platformValue = platformSelect.value; 

            if (!identifier) {
                playerStatsMessageDiv.textContent = 'Player Name or UID is required.';
                playerStatsMessageDiv.className = 'text-sm font-medium text-red-500';
                playerStatsContentDiv.innerHTML = '<p>Enter player details and click "Get Player Stats" to see results.</p>';
                return;
            }

            try {
                let profileResponse, sessionsResponse;

                if (selectedApi === 'tracker') {
                                const trackerProfileUrl = `${API_BASE_URL}/api/tracker-stats?platform=${platformValue}&identifier=${encodeURIComponent(identifier)}&type=profile`;
            const trackerSessionsUrl = `${API_BASE_URL}/api/tracker-stats?platform=${platformValue}&identifier=${encodeURIComponent(identifier)}&type=sessions`;
                    
                    [profileResponse, sessionsResponse] = await Promise.all([
                        fetch(trackerProfileUrl),
                        fetch(trackerSessionsUrl)
                    ]);

                    if (!profileResponse.ok) {
                        const errorData = await profileResponse.json();
                        throw new Error(errorData.message || `Tracker.gg Profile API error: ${profileResponse.status}`);
                    }
                    const profileData = await profileResponse.json();
                    renderPlayerStatsTrackerGG(profileData);

                    if (sessionsResponse.ok) {
                        const sessionsData = await sessionsResponse.json();
                        renderMatchHistoryTrackerGG(sessionsData);
                    } else {
                        const errorData = await sessionsResponse.json();
                        matchHistoryContentDiv.innerHTML = `<p class="text-gray-500">Could not load match history: ${errorData.message || sessionsResponse.statusText}.</p>`;
                        matchHistoryResultDiv.style.display = 'block'; 
                        console.warn('Tracker.gg Sessions API error:', errorData.message || sessionsResponse.statusText);
                    }

                } else { // MozambiqueHe.re selected
                    const mozambiquePlatform = platformSelect.options[platformSelect.selectedIndex].getAttribute('data-mozambique-platform');
                    let mozambiqueApiUrl = `https://api.mozambiquehe.re/bridge?auth=${MOZAMBIQUE_API_KEY}&platform=${mozambiquePlatform}`;
                    
                    if (useUidCheckbox.checked) {
                        mozambiqueApiUrl += `&uid=${identifier}`;
                    } else {
                        mozambiqueApiUrl += `&player=${identifier}`;
                    }

                    profileResponse = await fetch(mozambiqueApiUrl);

                    if (!profileResponse.ok) {
                        const errorData = await profileResponse.json();
                        throw new Error(errorData.Error || `MozambiqueHe.re API error: ${profileResponse.status}`);
                    }
                    const profileData = await profileResponse.json();
                    renderPlayerStatsMozambique(profileData);
                }

            } catch (error) {
                playerStatsMessageDiv.textContent = `Error: ${error.message}`;
                playerStatsMessageDiv.className = 'text-sm font-medium text-red-500';
                playerStatsContentDiv.innerHTML = `<p class="text-red-500">Failed to load player stats. ${error.message}</p>`;
                matchHistoryContentDiv.innerHTML = `<p class="text-red-500">Failed to load match history. ${error.message}</p>`;
                matchHistoryResultDiv.style.display = 'block'; 
                console.error('Error fetching player stats:', error);
            }
        }

        function renderPlayerStatsTrackerGG(data) {
            playerStatsMessageDiv.textContent = ''; 
            if (!data.success && data.message) {
                playerStatsContentDiv.innerHTML = `<p class="text-red-500">Error: ${data.message}</p>`;
                return;
            }
            if (!data.data) {
                playerStatsContentDiv.innerHTML = `<p class="text-red-500">Error: Player not found or data is unavailable from Tracker.gg.</p>`;
                return;
            }

            const player = data.data;
            const segments = player.segments;
            const overview = segments.find(s => s.type === 'overview');
            const lifetimeStats = overview?.stats;
            const rankSegment = segments.find(s => s.type === 'playlist' && s.attributes.playlistId === 'ranked');
            const currentRank = rankSegment?.stats?.rankScore;
            const selectedLegendSegment = segments.find(s => s.type === 'legend' && s.metadata.isActive);
            const legendImageUrl = selectedLegendSegment?.metadata?.imageUrl || '';

            let statsHtml = `
                <div class="flex flex-col lg:flex-row gap-8">
                    <!-- Left Column: Player Info & Rank -->
                    <div class="flex-none lg:w-1/3 space-y-6">
                        <div class="stat-card text-center">
                            <img src="${player.platformInfo?.avatarUrl || 'https://placehold.co/100x100/1f2937/e5e7eb?text=?'}" alt="Avatar" class="w-24 h-24 rounded-full mx-auto mb-4 border-2 border-emerald-500">
                            <h4 class="text-2xl font-bold text-white">${player.platformInfo?.platformUserHandle || 'N/A'}</h4>
                            <p class="text-gray-400">${player.platformInfo?.platformSlug?.toUpperCase() || 'N/A'}</p>
                        </div>
                        <div class="stat-card">
                            <h5 class="text-gray-400 text-sm mb-2">Current Rank</h5>
                            <div class="flex items-center gap-4">
                                <img src="${currentRank?.metadata?.iconUrl || ''}" alt="${currentRank?.metadata?.rankName || ''}" class="h-16 w-16">
                                <div>
                                    <p class="text-xl font-bold text-white">${currentRank?.metadata?.rankName || 'N/A'}</p>
                                    <p class="text-emerald-400">${currentRank?.value?.toLocaleString() || 'N/A'} RP</p>
                                </div>
                            </div>
                        </div>
                         <div class="stat-card">
                            <h5 class="text-gray-400 text-sm mb-1">Level</h5>
                            <p class="text-3xl font-bold text-white">${lifetimeStats?.level?.displayValue || 'N/A'}</p>
                        </div>
                    </div>

                    <!-- Right Column: Legend & Lifetime Stats -->
                    <div class="flex-grow space-y-6">
                        <div class="stat-card legend-card" style="background-image: url('${legendImageUrl}')">
                            <h5 class="text-gray-300 text-sm mb-2">Selected Legend</h5>
                            <p class="text-3xl font-bold text-white mb-4">${selectedLegendSegment?.metadata?.name || 'N/A'}</p>
                            <div class="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                                ${selectedLegendSegment?.stats ? Object.values(selectedLegendSegment.stats).map(stat => `
                                    <div>
                                        <span class="text-gray-400">${stat.displayName}: </span>
                                        <span class="font-semibold text-white">${stat.displayValue}</span>
                                    </div>
                                `).join('') : '<p>No stats for this legend.</p>'}
                            </div>
                            ${selectedLegendSegment?.metadata?.name !== 'N/A' ? `<button onclick="getLegendTips('${selectedLegendSegment.metadata.name}')" class="mt-4 bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded-full text-xs transition-colors duration-200">Get Legend Tips </button>` : ''}
                        </div>
                        <div class="stat-card">
                            <h5 class="text-gray-400 text-sm mb-2">Lifetime Stats</h5>
                             <div class="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-3 text-sm">
                                ${lifetimeStats ? Object.values(lifetimeStats).map(stat => {
                                    if (!stat.displayValue || stat.displayValue === 'N/A' || ['level', 'rankScore'].includes(stat.metadata.key)) return '';
                                    return `<div>
                                        <span class="text-gray-400">${stat.displayName}: </span>
                                        <span class="font-semibold text-white">${stat.displayValue}</span>
                                    </div>`;
                                }).join('') : '<p>No lifetime stats.</p>'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            playerStatsContentDiv.innerHTML = statsHtml;
        }

        function renderPlayerStatsMozambique(data) {
            playerStatsMessageDiv.textContent = '';
            matchHistoryResultDiv.style.display = 'none';

            if (data.Error) {
                playerStatsContentDiv.innerHTML = `<p class="text-red-500">Error: ${data.Error}</p>`;
                return;
            }
            if (!data.global) {
                playerStatsContentDiv.innerHTML = `<p class="text-red-500">Error: Player not found or data is unavailable from MozambiqueHe.re.</p>`;
                return;
            }

            const global = data.global;
            const legend = data.legends.selected;
            const legendImageUrl = legend?.ImgAssets?.banner || '';

            let statsHtml = `
                <div class="flex flex-col lg:flex-row gap-8">
                    <!-- Left Column: Player Info & Rank -->
                    <div class="flex-none lg:w-1/3 space-y-6">
                        <div class="stat-card text-center">
                            <img src="${global.avatar || 'https://placehold.co/100x100/1f2937/e5e7eb?text=?'}" alt="Avatar" class="w-24 h-24 rounded-full mx-auto mb-4 border-2 border-emerald-500">
                            <h4 class="text-2xl font-bold text-white">${global.name || 'N/A'}</h4>
                            <p class="text-gray-400">${global.platform || 'N/A'}</p>
                        </div>
                        <div class="stat-card">
                            <h5 class="text-gray-400 text-sm mb-2">Current Rank</h5>
                            <div class="flex items-center gap-4">
                                <img src="${global.rank?.rankImg || ''}" alt="${global.rank?.rankName || ''}" class="h-16 w-16">
                                <div>
                                    <p class="text-xl font-bold text-white">${global.rank?.rankName || 'N/A'} ${global.rank?.rankDiv || ''}</p>
                                    <p class="text-emerald-400">${global.rank?.rankScore?.toLocaleString() || 'N/A'} RP</p>
                                </div>
                            </div>
                        </div>
                         <div class="stat-card">
                            <h5 class="text-gray-400 text-sm mb-1">Level</h5>
                            <p class="text-3xl font-bold text-white">${global.level || 'N/A'}</p>
                        </div>
                    </div>

                    <!-- Right Column: Legend & Recent Matches -->
                    <div class="flex-grow space-y-6">
                        <div class="stat-card legend-card" style="background-image: url('${legendImageUrl}')">
                            <h5 class="text-gray-300 text-sm mb-2">Selected Legend</h5>
                            <p class="text-3xl font-bold text-white mb-4">${legend?.LegendName || 'N/A'}</p>
                            <div class="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                                ${legend?.data ? legend.data.map(stat => `
                                    <div>
                                        <span class="text-gray-400">${stat.name}: </span>
                                        <span class="font-semibold text-white">${stat.value?.toLocaleString() || '0'}</span>
                                    </div>
                                `).join('') : '<p>No stats for this legend.</p>'}
                            </div>
                             ${legend?.LegendName ? `<button onclick="getLegendTips('${legend.LegendName}')" class="mt-4 bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded-full text-xs transition-colors duration-200">Get Legend Tips </button>` : ''}
                        </div>
                        <div class="stat-card">
                            <h5 class="text-gray-400 text-sm mb-2">Recent Matches</h5>
                            <div class="space-y-2">
                                 ${data.history?.length > 0 ? 
                                    data.history.slice(0, 5).map(match => `
                                        <div class="text-sm">
                                            <span class="font-semibold text-white">${match.gameMode || 'N/A'}</span> - Kills: <span class="text-emerald-400">${match.kills?.toLocaleString() || '0'}</span>, Damage: <span class="text-emerald-400">${match.damage?.toLocaleString() || '0'}</span> <span class="text-gray-500 text-xs">(${new Date(match.timestamp * 1000).toLocaleDateString()})</span>
                                        </div>
                                    `).join('')
                                 : '<p class="text-gray-500">No recent match history available.</p>'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            playerStatsContentDiv.innerHTML = statsHtml;
        }

        function renderMatchHistoryTrackerGG(data) {
            matchHistoryResultDiv.style.display = 'block';
            matchHistoryContentDiv.innerHTML = '';

            if (!data.success && data.message) {
                matchHistoryContentDiv.innerHTML = `<p class="text-red-500">Error: ${data.message}</p>`;
                return;
            }
            if (!data || !data.data || data.data.length === 0) {
                matchHistoryContentDiv.innerHTML = '<p class="text-gray-500">No recent match history available for this player.</p>';
                return;
            }

            let historyHtml = '<div class="space-y-4">';
            data.data.forEach(session => {
                historyHtml += `
                    <div class="stat-card">
                        <h5 class="text-lg font-bold text-white mb-2">${session.metadata.name || 'Game Session'}</h5>
                        <p class="text-sm text-gray-400 mb-3">${new Date(session.metadata.startDate).toLocaleString()}</p>
                        <div class="space-y-3">
                `;
                if (session.matches && session.matches.length > 0) {
                    session.matches.forEach(match => {
                        const matchStats = match.stats;
                        const kills = matchStats?.kills?.displayValue || '0';
                        const damage = matchStats?.damage?.displayValue || '0';
                        const gameMode = match.metadata?.playlistName || 'N/A';
                        const legendPlayed = match.metadata?.legendName || 'N/A';
                        historyHtml += `
                            <div class="match-card">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <span class="font-semibold text-white">${legendPlayed}</span>
                                        <span class="text-gray-400"> in ${gameMode}</span>
                                    </div>
                                    <div class="text-right">
                                        <p class="text-sm">Kills: <span class="font-bold text-emerald-400">${kills}</span></p>
                                        <p class="text-sm">Damage: <span class="font-bold text-emerald-400">${damage}</span></p>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    historyHtml += `<p class="text-gray-500">No detailed matches for this session.</p>`;
                }
                historyHtml += '</div></div>';
            });
            historyHtml += '</div>';
            matchHistoryContentDiv.innerHTML = historyHtml;
        }


        const updatePaginationControls = () => {
            const totalPages = Math.ceil(filteredAndSortedPlayers.length / itemsPerPage);
            pageNumbersDiv.innerHTML = ''; 

            for (let i = 1; i <= totalPages; i++) {
                const pageButton = document.createElement('button');
                pageButton.textContent = i;
                pageButton.className = `px-3 py-1 rounded-lg ${i === currentPage ? 'bg-indigo-600 text-white' : 'bg-gray-700 hover:bg-gray-600'} transition-colors duration-200`;
                pageButton.onclick = () => {
                    currentPage = i;
                    updateLeaderboardAndPagination();
                };
                pageNumbersDiv.appendChild(pageButton);
            }

            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;
        };

        const updateLeaderboardAndPagination = () => {
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const playersToRender = filteredAndSortedPlayers.slice(startIndex, endIndex);
            
            renderLeaderboard(playersToRender);
            updatePaginationControls();
            
            // Load cached legends for current page
            setTimeout(() => loadCachedLegends(), 100);
        };

        prevPageBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                updateLeaderboardAndPagination();
            }
        });

        nextPageBtn.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredAndSortedPlayers.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                updateLeaderboardAndPagination();
            }
        });


        async function initializeApp() {
            try {
                // No-op: AI Analysis fully removed and replaced by Multi-Stream column
                // Load data as JavaScript files to bypass ad blockers
                const loadData = async () => {
                    // Check localStorage cache first
                    const cacheKey = 'leaderboard_cache';
                    const cacheExpiry = 60000; // 1 minute cache
                    const cached = localStorage.getItem(cacheKey);
                    
                    if (cached) {
                        try {
                            const { data, timestamp } = JSON.parse(cached);
                            const age = Date.now() - timestamp;
                            
                            if (age < cacheExpiry) {
                                console.log('Using cached leaderboard data, age:', Math.round(age/1000) + 's');
                                // Use cached data immediately
                                window.leaderboardData = data.leaderboardData;
                                window.predatorThresholds = data.predatorData;
                                
                                // Still fetch fresh data in background
                                fetch(`${API_BASE_URL}/api/leaderboard/PC`)
                                    .then(r => r.json())
                                    .then(fresh => {
                                        if (fresh.success && fresh.data) {
                                            // Update cache with fresh data
                                            const newCache = {
                                                data: { leaderboardData: fresh.data, predatorData: window.predatorThresholds },
                                                timestamp: Date.now()
                                            };
                                            localStorage.setItem(cacheKey, JSON.stringify(newCache));
                                            console.log('Updated cache with fresh data');
                                        }
                                    })
                                    .catch(e => console.warn('Background refresh failed:', e));
                                
                                return data;
                            }
                        } catch (e) {
                            console.warn('Cache parse error:', e);
                        }
                    }
                    // Start both requests in parallel
                    const [leaderboardResponse, predatorResponse] = await Promise.allSettled([
                        fetch(`${API_BASE_URL}/api/leaderboard/PC`),
                        fetch(`${API_BASE_URL}/api/predator-points`)
                    ]);
                    
                    // Process leaderboard (required)
                    if (leaderboardResponse.status === 'rejected') {
                        throw new Error('Failed to load leaderboard data');
                    }
                    const leaderboardJson = await leaderboardResponse.value.json();
                    if (!leaderboardJson.success || !leaderboardJson.data?.players) {
                        throw new Error('Invalid leaderboard data format');
                    }
                    
                    // Process predator data (optional - don't fail if it doesn't load)
                    let predatorData = null;
                    if (predatorResponse.status === 'fulfilled') {
                        try {
                            console.log('Predator response status:', predatorResponse.value.status);
                            const predatorJson = await predatorResponse.value.json();
                            console.log('Raw predator JSON response:', predatorJson);
                            
                            if (predatorJson?.success && predatorJson.data) {
                                predatorData = predatorJson.data;
                                console.log('Extracted predator data:', predatorData);
                                } else {
                                console.warn('Predator API returned success=false or no data:', predatorJson);
                            }
                        } catch (e) {
                            console.error('Failed to parse predator JSON:', e);
                        }
                    } else {
                        console.error('Predator request failed:', predatorResponse.reason);
                    }
                    
                    // Store in window for backward compatibility
                    window.leaderboardData = leaderboardJson.data;
                    window.predatorThresholds = predatorData;
                    
                    const result = {
                        leaderboardData: leaderboardJson.data,
                        predatorData: predatorData
                    };
                    
                    // Cache the successful result
                    try {
                        const cacheData = {
                            data: result,
                            timestamp: Date.now()
                        };
                        localStorage.setItem('leaderboard_cache', JSON.stringify(cacheData));
                        console.log('Cached leaderboard data');
                    } catch (e) {
                        console.warn('Failed to cache data:', e);
                    }
                    
                    return result;
                };
                
                // Fetch environment variables first (for Supabase)
                try {
                    const [envRes, flagsRes] = await Promise.all([
                        fetch(`/api/public-env`),
                        fetch(`/api/edge-config/public`)
                    ]);
                    try {
                        const envData = await envRes.json();
                        if (envData?.success && envData.data) {
                            window.env = envData.data;
                            window.__supabaseConfig = { 
                                url: envData.data.NEXT_PUBLIC_SUPABASE_URL, 
                                anon: envData.data.NEXT_PUBLIC_SUPABASE_ANON_KEY 
                            };
                        }
                    } catch {}
                    try {
                        const flags = await flagsRes.json();
                        if (flags?.success && flags.data) {
                            window.__edgeFlags = Object.assign(window.__edgeFlags || {}, flags.data);
                        }
                    } catch {}
                } catch (err) { 
                    console.warn('Failed to fetch env/flags:', err);
                }

                // Load all critical data in parallel
                const [dataResult] = await Promise.all([
                    loadData(),
                    initSupabase() // Initialize Supabase early for favorites
                ]);
                
                let { leaderboardData, predatorData } = dataResult;
                
                if (!leaderboardData?.players) throw new Error("Invalid leaderboard data structure.");
                
                // Debug: Log the predator data (allow it to be null)
                console.log('Predator Data received:', predatorData);
                console.log('Predator Data type:', typeof predatorData);
                console.log('Predator Data keys:', predatorData ? Object.keys(predatorData) : 'null');
                
                // Provide fallback data if predator data is missing
                if (!predatorData) {
                    console.warn('No predator data received, using fallback');
                    predatorData = {
                        PC: null,
                        PS4: null, 
                        X1: null,
                        SWITCH: null
                    };
                }

                allPlayers = leaderboardData.players.map(player => {
                    const isLive = player.twitch_live?.is_live === true;
                    const streamData = isLive ? player.twitch_live.stream_data : null;
                    const userData = player.twitch_live?.user_data || {};
                    let displayName = player.player_name;
                    const isGenericName = (displayName.toLowerCase().startsWith('player') && !isNaN(displayName.substring(6))) || displayName.toLowerCase() === 'empty name';
                    
                    if (isGenericName) {
                        if (isLive && streamData?.user_name) {
                            displayName = streamData.user_name;
                        } else if (userData.display_name) {
                            displayName = userData.display_name;
                        } else if (player.twitch_link) {
                            try {
                                const pathSegments = new URL(player.twitch_link).pathname.split('/').filter(Boolean);
                                if (pathSegments.length > 0) displayName = pathSegments.pop();
                            } catch (e) { /* ignore parsing errors */ }
                        }
                    }

                    return {
                        rank: player.rank,
                        name: displayName, 
                        rp: player.rp, 
                        change: player.rp_change_24h,
                        level: player.level, 
                        status: isLive ? 'Live' : player.status, 
                        twitchLink: player.twitch_link,
                        stream: streamData ? { viewers: streamData.viewer_count, game: streamData.game_name, twitchUser: streamData.user_name } : null,
                        vods_enabled: player.vods_enabled,
                        recent_videos: player.recent_videos || [],
                        hasClips: player.hasClips,
                        recentClips: player.recentClips || [],
                        //  ADD MISSING TWITCH_LIVE DATA
                        twitch_live: player.twitch_live,
                        canonical_twitch_username: player.canonical_twitch_username,
                        country_code: player.country_code || null,
                        input_device: player.input_device || null
                    };
                });
                
                // Favorites should already be loaded from earlier initSupabase()
                filteredAndSortedPlayers = [...allPlayers]; 
                currentPage = 1; 
                updateLeaderboardAndPagination(); 

                // Load legends for top players automatically
                setTimeout(() => {
                    console.log('Starting auto legend loading...');
                    console.log('Current filteredAndSortedPlayers:', filteredAndSortedPlayers.slice(0, 3).map(p => p.name));
                    loadTopPlayerLegends();
                }, 3000); // Increased delay to ensure leaderboard is fully rendered
                
                // Also try loading cached legends immediately
                setTimeout(() => {
                    console.log('Loading cached legends immediately...');
                    loadCachedLegends();
                }, 500);
                
                // Make functions available globally for debugging
                window.debugFetchLegend = fetchPlayerLegend;
                window.debugLoadTopLegends = loadTopPlayerLegends;
                window.debugPredatorAPI = async () => {
                    try {
                        console.log('Testing predator API...');
                        const response = await fetch(`${API_BASE_URL}/api/predator-points`);
                        const data = await response.json();
                        console.log('Predator API test result:', data);
                        return data;
                    } catch (error) {
                        console.error('Predator API test failed:', error);
                        return null;
                    }
                };
                window.debugLegendCache = () => {
                    const cache = getLegendCache();
                    console.log('Current legend cache:', cache);
                    console.log('Cache size:', Object.keys(cache).length);
                    for (const [player, entry] of Object.entries(cache)) {
                        const age = Math.round((Date.now() - entry.timestamp) / 1000 / 60);
                        console.log(`${player}: ${entry.data?.name || 'null'} (${age}m old)`);
                    }
                    return cache;
                };
                window.debugClearLegendCache = () => {
                    localStorage.removeItem(LEGEND_CACHE_KEY);
                    console.log('Legend cache cleared');
                };
                window.debugLoadCachedLegends = loadCachedLegends;

                renderPredatorThresholds(predatorData);
                renderRpDistributionChart(allPlayers);
                renderPlatformDistributionChart(predatorData);
                
                // Update streamers count
                updateStreamersCount();
                
                // Load additional data
                loadGameStatus();
                
            } catch (error) {
                console.error('Failed to initialize app:', error);
                leaderboardBody.innerHTML = `<tr><td colspan="8" class="px-6 py-4 text-center text-red-500">Failed to load data. Error: ${error.message}</td></tr>`; 
                predatorThresholdsDiv.innerHTML = `<p class="text-red-500 col-span-4 text-center">Could not load predator thresholds.</p>`;
            }
        }

        searchInput.addEventListener('input', applyFilters);
        liveOnlyToggle.addEventListener('change', applyFilters);
        overrideForm.addEventListener('submit', submitTwitchOverride); 
        playerStatsForm.addEventListener('submit', fetchPlayerStats); 
        // Live Rewind & Clip Functions - REMOVED

        async function loadLiveStreamers() {
            try {
                const response = await fetch('/twitch/live-streamers');
                const data = await response.json();
                
                if (data.success) {
                    populateLiveStreamersDropdown(data.streamers);
                } else {
                    alert('Failed to load live streamers: ' + data.error);
                }
            } catch (error) {
                console.error('Error loading live streamers:', error);
                alert('Error loading live streamers: ' + error.message);
            }
        }

        function populateLiveStreamersDropdown(streamers) {
            const select = document.getElementById('liveStreamerSelect');
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">-- Select a live streamer --</option>';
            
            if (streamers.length === 0) {
                select.innerHTML += '<option value="" disabled>No live streamers found</option>';
                return;
            }
            
            // Add streamer options
            streamers.forEach(streamer => {
                const option = document.createElement('option');
                option.value = streamer.login;
                option.textContent = `${streamer.displayName} (${streamer.viewersCount} viewers) - Rank ${streamer.rank}`;
                option.dataset.streamer = JSON.stringify(streamer);
                select.appendChild(option);
            });
            
            // Add change event listener
            select.onchange = function() {
                if (this.value) {
                    const streamer = JSON.parse(this.options[this.selectedIndex].dataset.streamer);
                    showSelectedStreamerInfo(streamer);
                } else {
                    hideSelectedStreamerInfo();
                }
            };
        }
        
        function showSelectedStreamerInfo(streamer) {
            document.getElementById('streamerAvatar').src = streamer.profileImageURL;
            document.getElementById('streamerName').textContent = streamer.displayName;
            document.getElementById('streamerTitle').textContent = streamer.title || 'Apex Legends';
            document.getElementById('streamerViewers').textContent = `${streamer.viewersCount} viewers`;
            document.getElementById('streamerRank').textContent = `Rank ${streamer.rank}`;
            document.getElementById('selectedStreamerInfo').style.display = 'block';
        }
        
        function hideSelectedStreamerInfo() {
            document.getElementById('selectedStreamerInfo').style.display = 'none';
        }
        
        function selectStreamerFromDropdown() {
            const select = document.getElementById('liveStreamerSelect');
            if (select.value) {
                const streamer = JSON.parse(select.options[select.selectedIndex].dataset.streamer);
                selectStreamer(streamer.login);
            }
        }

        function selectStreamer(channelLogin) {
            document.getElementById('liveRewindChannelInput').value = channelLogin;
            getLiveStreamInfo();
        }

        function quickRewind(channelLogin) {
            // Switch to the live rewind tab
            showTab('liveRewindTab');
            
            // Set the channel input
            document.getElementById('liveRewindChannelInput').value = channelLogin;
            
            // Automatically get stream info
            setTimeout(() => {
                getLiveStreamInfo();
            }, 100);
        }

        async function getLiveStreamInfo() {
            const channelLogin = document.getElementById('liveRewindChannelInput').value.trim();
            if (!channelLogin) {
                alert('Please enter a channel name');
                return;
            }

            try {
                const response = await fetch(`/twitch/live-stream/${channelLogin}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tokens: getTokensFromCookies()
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    currentLiveChannel = channelLogin;
                    currentM3u8Url = data.source_m3u8;
                    
                    document.getElementById('liveStreamInfo').innerHTML = `
                        <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-4 mb-4">
                            <div class="flex items-center mb-2">
                                <div class="w-3 h-3 bg-green-500 rounded-full mr-2 animate-pulse"></div>
                                <span class="text-green-400 font-semibold">LIVE</span>
                            </div>
                            <p class="text-gray-300">Channel: <span class="text-white">${data.channel}</span></p>
                            <p class="text-gray-300">Quality: <span class="text-white">${Object.keys(data.quality_options).join(', ')}</span></p>
                            <p class="text-xs text-gray-500 mt-2">Ready to start buffering live stream segments</p>
                        </div>
                    `;
                    
                    // Set up video player with the M3U8 URL
                    setupVideoPlayer(data.source_m3u8);
                    
                    document.getElementById('liveStreamInfoSection').style.display = 'block';
                    document.getElementById('bufferStatusSection').style.display = 'block';
                    document.getElementById('clipCreatorSection').style.display = 'block';
                    
                    // Auto-start buffering
                    await startLiveBuffer();
                    
                    // Start monitoring buffer status
                    updateBufferStatus();
                } else {
                    document.getElementById('liveStreamInfo').innerHTML = `
                        <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-4">
                            <p class="text-red-400">Error: ${data.error}</p>
                        </div>
                    `;
                    document.getElementById('liveStreamInfoSection').style.display = 'block';
                }
            } catch (error) {
                console.error('Error getting live stream info:', error);
                document.getElementById('liveStreamInfo').innerHTML = `
                    <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-4">
                        <p class="text-red-400">Error: ${error.message}</p>
                    </div>
                `;
                document.getElementById('liveStreamInfoSection').style.display = 'block';
            }
        }

        function setupVideoPlayer(streamUrl) {
            const video = document.getElementById('liveStreamVideo');
            const source = document.getElementById('liveStreamSource');
            
            // Check if it's a Twitch URL (placeholder) or actual M3U8 URL
            if (streamUrl.includes('twitch.tv/')) {
                // This is a placeholder Twitch URL - show a message instead of trying to play
                console.log('Stream URL is a placeholder:', streamUrl);
                document.getElementById('bufferStatusText').textContent = 'Stream is Live - M3U8 extraction in progress';
                
                // Show the video player section with a placeholder
                document.getElementById('liveStreamPlayerSection').style.display = 'block';
                
                // Create a placeholder video element
                video.innerHTML = `
                    <div class="flex items-center justify-center h-full bg-gray-900 text-white">
                        <div class="text-center">
                            <div class="w-16 h-16 bg-red-600 rounded-full flex items-center justify-center mx-auto mb-4">
                                <span class="text-2xl"></span>
                            </div>
                            <h3 class="text-lg font-semibold mb-2">Live Stream Detected</h3>
                            <p class="text-gray-400 mb-4">Stream is live and ready for buffering</p>
                            <p class="text-sm text-gray-500">M3U8 URL extraction in development</p>
                            <a href="${streamUrl}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">
                                Watch on Twitch
                            </a>
                        </div>
                    </div>
                `;
                
                return;
            }
            
            // Check if HLS.js is available for actual M3U8 URLs
            if (Hls.isSupported()) {
                const hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                });
                
                hls.loadSource(streamUrl);
                hls.attachMedia(video);
                
                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    console.log('HLS manifest loaded, video ready to play');
                    video.play().catch(e => console.log('Auto-play prevented:', e));
                });
                
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error('HLS error:', data);
                });
                
                // Store HLS instance for cleanup
                video.hls = hls;
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                source.src = streamUrl;
                video.load();
                video.play().catch(e => console.log('Auto-play prevented:', e));
            } else {
                console.error('HLS not supported in this browser');
                document.getElementById('bufferStatusText').textContent = 'HLS Not Supported';
            }
            
            // Show the video player section
            document.getElementById('liveStreamPlayerSection').style.display = 'block';
            
            // Update overlay text
            document.getElementById('bufferStatusText').textContent = 'Live Stream';
            
            console.log('Video player set up with stream URL:', streamUrl);
        }

        function toggleVideoPlayer() {
            const playerSection = document.getElementById('liveStreamPlayerSection');
            if (playerSection.style.display === 'none') {
                playerSection.style.display = 'block';
            } else {
                playerSection.style.display = 'none';
            }
        }

        async function startLiveBuffer() {
            if (!currentM3u8Url) {
                console.log('No M3U8 URL available for buffering');
                return;
            }

            try {
                const response = await fetch(`/twitch/start-buffer/${currentLiveChannel}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        m3u8_url: currentM3u8Url
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    console.log(' Auto-started buffering live stream! Ready for rewinding and clipping.');
                    updateBufferStatus();
                } else {
                    console.error('Error starting buffer:', data.error);
                }
            } catch (error) {
                console.error('Error starting buffer:', error);
            }
        }

        async function stopLiveBuffer() {
            if (!currentLiveChannel) {
                alert('No active buffer to stop');
                return;
            }

            try {
                const response = await fetch(`/twitch/stop-buffer/${currentLiveChannel}`, {
                    method: 'POST'
                });

                const data = await response.json();
                
                if (data.success) {
                    alert('Stopped buffering live stream');
                    
                    // Clean up video player
                    const video = document.getElementById('liveStreamVideo');
                    if (video.hls) {
                        video.hls.destroy();
                        video.hls = null;
                    }
                    video.pause();
                    video.src = '';
                    
                    currentLiveChannel = null;
                    currentM3u8Url = null;
                    document.getElementById('liveStreamInfoSection').style.display = 'none';
                    document.getElementById('bufferStatusSection').style.display = 'none';
                    document.getElementById('clipCreatorSection').style.display = 'none';
                    document.getElementById('liveStreamPlayerSection').style.display = 'none';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error stopping buffer:', error);
                alert('Error stopping buffer: ' + error.message);
            }
        }

        async function updateBufferStatus() {
            if (!currentLiveChannel) return;

            try {
                const response = await fetch(`/twitch/buffer-status/${currentLiveChannel}`);
                const data = await response.json();
                
                if (data.success) {
                    const statusHtml = data.is_buffering ? 
                        `<div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
                            <div class="flex items-center mb-2">
                                <div class="w-3 h-3 bg-blue-500 rounded-full mr-2 animate-pulse"></div>
                                <span class="text-blue-400 font-semibold">BUFFERING LIVE STREAM</span>
                            </div>
                            <p class="text-gray-300">Segments captured: <span class="text-white">${data.segments_count}</span></p>
                            <p class="text-gray-300">Buffer duration: <span class="text-white">${data.buffer_duration.toFixed(1)} seconds</span></p>
                            <p class="text-gray-300">Segment duration: <span class="text-white">${data.segment_duration} seconds</span></p>
                            <p class="text-gray-300">Max rewind available: <span class="text-white">${data.max_rewind_available}</span></p>
                            <p class="text-xs text-gray-500 mt-2"> Works with VOD-disabled streamers - capturing HLS segments in real-time</p>
                        </div>` :
                        `<div class="bg-gray-900/20 border border-gray-500/30 rounded-lg p-4">
                            <p class="text-gray-400">Buffer not active</p>
                            <p class="text-xs text-gray-500 mt-2">Start buffering to capture live stream segments</p>
                        </div>`;
                    
                    document.getElementById('bufferStatus').innerHTML = statusHtml;
                    
                    // Update video overlay with buffer status
                    const overlayText = document.getElementById('bufferStatusText');
                    if (data.is_buffering) {
                        overlayText.textContent = `Buffering: ${data.buffer_duration.toFixed(1)}s`;
                        overlayText.className = 'absolute top-2 right-2 bg-blue-600/80 text-white px-2 py-1 rounded text-xs animate-pulse';
                    } else {
                        overlayText.textContent = 'Live Stream';
                        overlayText.className = 'absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded text-xs';
                    }
                }
            } catch (error) {
                console.error('Error updating buffer status:', error);
            }
        }

        async function getRewindSegments() {
            if (!currentLiveChannel) {
                alert('Please start buffering first');
                return;
            }

            const seconds = document.getElementById('rewindSeconds').value;
            
            try {
                const response = await fetch(`/twitch/rewind/${currentLiveChannel}/${seconds}`);
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('rewindResults').innerHTML = `
                        <div class="bg-purple-900/20 border border-purple-500/30 rounded-lg p-4">
                            <p class="text-purple-400 font-semibold mb-2">Rewind Results</p>
                            <p class="text-gray-300">Channel: <span class="text-white">${data.channel}</span></p>
                            <p class="text-gray-300">Requested rewind: <span class="text-white">${data.requested_rewind_seconds} seconds ago</span></p>
                            <p class="text-gray-300">Available rewind: <span class="text-white">${data.available_rewind_seconds.toFixed(1)} seconds</span></p>
                            <p class="text-gray-300">Segments available: <span class="text-white">${data.segments_available}</span></p>
                            <p class="text-gray-300">Total buffered: <span class="text-white">${data.total_buffered_duration.toFixed(1)} seconds</span></p>
                            <p class="text-gray-300">Segment duration: <span class="text-white">${data.segment_duration} seconds</span></p>
                            <p class="text-xs text-gray-500 mt-2">${data.message} - Ready for clip creation</p>
                        </div>
                    `;
                    document.getElementById('rewindResultsSection').style.display = 'block';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error getting rewind segments:', error);
                alert('Error getting rewind segments: ' + error.message);
            }
        }

        async function createClipFromBuffer() {
            if (!currentLiveChannel) {
                alert('Please start buffering first');
                return;
            }

            const startSeconds = document.getElementById('clipStartSeconds').value;
            const duration = document.getElementById('clipDuration').value;
            
            try {
                const response = await fetch(`/api/stream-create-clip/${currentLiveChannel}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        start_seconds: parseInt(startSeconds),
                        duration: parseInt(duration)
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('clipResult').innerHTML = `
                        <div class="bg-orange-900/20 border border-orange-500/30 rounded-lg p-4">
                            <p class="text-orange-400 font-semibold mb-2">Clip Created Successfully!</p>
                            <p class="text-gray-300">Clip ID: <span class="text-white">${data.clip_id}</span></p>
                            <p class="text-gray-300">Start time: <span class="text-white">${data.start_time} seconds ago</span></p>
                            <p class="text-gray-300">Duration: <span class="text-white">${data.duration} seconds</span></p>
                            <p class="text-gray-300">Segments used: <span class="text-white">${data.segments_count}</span></p>
                            <p class="text-xs text-gray-500 mt-2">${data.message}</p>
                        </div>
                    `;
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error creating clip:', error);
                alert('Error creating clip: ' + error.message);
            }
        }

        window.onload = initializeApp;

        // Initialize API source selection
        handleApiSourceChange(); // Call on load to set initial state


        // Token extraction function (like the extension)
        function getTokensFromCookies() {
            const c = document.cookie;
            
            // Try multiple methods to extract OAuth token (like the extension)
            let oauthToken = null;
            
            // Method 1: Look for authToken in cookies
            const authTokenMatch = /(?<=%22authToken%22:%22).+?(?=%22)/.exec(c);
            if (authTokenMatch) {
                oauthToken = "OAuth " + authTokenMatch[0];
            }
            
            // Method 2: Look for access_token in cookies
            if (!oauthToken) {
                const accessTokenMatch = /(?<=access_token=).+?(?=;)/.exec(c);
                if (accessTokenMatch) {
                    oauthToken = "OAuth " + accessTokenMatch[0];
                }
            }
            
            // Method 3: Look for OAuth token in localStorage (if available)
            if (!oauthToken) {
                try {
                    const storedTokens = localStorage.getItem('tvd_twitch_tokens');
                    if (storedTokens) {
                        const parsed = JSON.parse(storedTokens);
                        if (parsed.oauth) {
                            oauthToken = parsed.oauth;
                        }
                    }
                } catch (e) {
                    console.log('Could not read from localStorage:', e);
                }
            }
            
            // Method 4: Look for OAuth token in script tags
            if (!oauthToken) {
                const scripts = Array.from(document.getElementsByTagName("script"));
                for (const script of scripts) {
                    if (script.innerHTML) {
                        const oauthMatch = /(?<="OAuth ").+?(?=")/.exec(script.innerHTML);
                        if (oauthMatch) {
                            oauthToken = "OAuth " + oauthMatch[0];
                            break;
                        }
                    }
                }
            }
            
            const tokens = {
                client_session_id: Array.from(document.querySelectorAll("img") || [])
                    .map((elm) => /(?<=sessionid=)\S+?(?=\&)/.exec(elm.src)?.[0])
                    ?.filter(Boolean)?.[0],
                video_id: /twitch\.tv\/videos\/(\d+)/.exec(window.location.href)?.[1],
                api_token: /(?<=api_token\=).+?(?=;)/.exec(c)?.[0],
                device_id: /(?<=unique_id\=).+?(?=;)/.exec(c)?.[0] || 'twitch-web-extension',
                authorization: oauthToken,
                oauth: oauthToken,
                client_id: "kimne78kx3ncx6brgo4mv6wki5h1ko", // Always use Twitch's web client ID
                user_id: /%22id%22:%22(\d+)%/.exec(c)?.[1],
                user_login: /%22login%22:%22(\w+)%/.exec(c)?.[1],
            };
            
            // Clean up undefined values
            Object.keys(tokens).forEach(key => {
                if (tokens[key] === undefined || tokens[key] === null || tokens[key] === "") {
                    delete tokens[key];
                }
            });
            
            console.log('Extracted tokens:', Object.keys(tokens));
            console.log('OAuth token found:', !!tokens.oauth);
            return tokens;
        }

        async function searchChannels() {
            const query = document.getElementById('channelSearchInput').value.trim();
            if (!query) {
                alert('Please enter a channel name to search');
                return;
            }

            const searchResults = document.getElementById('searchResults');
            searchResults.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Searching...</p>';

            try {
                const response = await fetch(`${API_BASE_URL}/api/stream-search`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ query })
                });

                const data = await response.json();
                
                if (data.success && data.channels.length > 0) {
                    let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';
                    data.channels.forEach(channel => {
                        html += `
                            <div class="bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors" onclick="selectChannel('${channel.broadcaster_login}')">
                                <div class="flex items-center gap-3">
                                    <img src="${channel.thumbnail_url}" alt="${channel.display_name}" class="w-12 h-12 rounded-full">
                                    <div>
                                        <h4 class="font-semibold text-white">${channel.display_name}</h4>
                                        <p class="text-sm text-gray-400">${channel.broadcaster_login}</p>
                                        <p class="text-xs text-gray-500">${channel.game_name || 'No game'}</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                    searchResults.innerHTML = html;
                } else {
                    searchResults.innerHTML = '<p class="text-gray-400">No channels found.</p>';
                }
            } catch (error) {
                searchResults.innerHTML = `<p class="text-red-500">Error: ${error.message}</p>`;
                console.error('Error searching channels:', error);
            }
        }

        async function selectChannel(channelLogin) {
            currentChannelLogin = channelLogin;
            
            try {
                // Get channel info
                const channelResponse = await fetch(`${API_BASE_URL}/api/stream-channel/${channelLogin}`, {
                });
                const channelData = await channelResponse.json();
                
                if (channelData.success) {
                    renderChannelInfo(channelData.channel);
                    
                    // Get recent streams with hidden VODs (like the extension)
                    const streamsResponse = await fetch(`${API_BASE_URL}/api/stream-recent/${channelLogin}`, {
                        method: 'GET',
                    });
                    const streamsData = await streamsResponse.json();
                    console.log('Recent streams data:', streamsData);
                    console.log('Streams array length:', streamsData.streams ? streamsData.streams.length : 'No streams array');
                    console.log('First stream:', streamsData.streams ? streamsData.streams[0] : 'No streams');
                    console.log('Hidden count:', streamsData.hidden_count, 'API count:', streamsData.api_count, 'Total:', streamsData.total_count);
                    
                    // Debug: Show actual dates and durations
                    if (streamsData.streams) {
                        console.log('Stream details:');
                        streamsData.streams.forEach((stream, i) => {
                            const date = stream.created_at ? new Date(stream.created_at).toLocaleDateString() : 'No date';
                            const duration = stream.duration ? `${Math.floor(stream.duration/3600)}h ${Math.floor((stream.duration%3600)/60)}m` : 'No duration';
                            console.log(`  ${i+1}. "${stream.title}" - ${duration} - ${date} - Hidden: ${stream.is_hidden}`);
                        });
                    }
                    
                    if (streamsData.success) {
                        renderVODsList(streamsData.streams, true); // Pass true to indicate these are recent streams
                    } else {
                        console.error('Streams API error:', streamsData.error);
                        document.getElementById('vodsList').innerHTML = `<p class="text-red-500">Error: ${streamsData.error}</p>`;
                    }
                    
                    // Check if live
                    const liveResponse = await fetch(`${API_BASE_URL}/api/stream-live/${channelLogin}`, {
                    });
                    const liveData = await liveResponse.json();
                    
                    if (liveData.success && liveData.live) {
                        renderLiveStream(liveData);
                    }
                }
            } catch (error) {
                console.error('Error selecting channel:', error);
            }
        }

        function renderChannelInfo(channel) {
            const channelInfoSection = document.getElementById('channelInfoSection');
            const channelInfo = document.getElementById('channelInfo');
            
            channelInfo.innerHTML = `
                <div class="flex items-center gap-4">
                    <img src="${channel.profile_image_url}" alt="${channel.display_name}" class="w-16 h-16 rounded-full">
                    <div>
                        <h4 class="text-xl font-bold text-white">${channel.display_name}</h4>
                        <p class="text-gray-400">@${channel.login}</p>
                        <p class="text-sm text-gray-500">${channel.description || 'No description'}</p>
                    </div>
                </div>
            `;
            
            channelInfoSection.style.display = 'block';
        }

        function renderVODsList(videos, isRecentStreams = false) {
            const vodsSection = document.getElementById('vodsSection');
            const vodsList = document.getElementById('vodsList');
            
            console.log(`renderVODsList called with ${videos.length} videos`);
            console.log('First 3 videos to render:', videos.slice(0, 3));
            
            if (videos.length === 0) {
                vodsList.innerHTML = '<p class="text-gray-400">No recent streams/VODs available for this channel.</p>';
                vodsSection.style.display = 'block';
                return;
            }
            
            let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';
            let renderedCount = 0;
            videos.forEach((video, index) => {
                renderedCount++;
                if (index < 5) {
                    console.log(`Rendering video ${index + 1}: "${video.title}" - Duration: ${video.duration}s - Hidden: ${video.is_hidden}`);
                }
                const duration = formatDuration(video.duration);
                const createdAt = new Date(video.created_at).toLocaleDateString();
                
                html += `
                    <div class="bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors" onclick="selectVideoFromData(${JSON.stringify(video).replace(/"/g, '&quot;')})" style="user-select: none;">
                        <div class="aspect-video bg-gray-800 rounded mb-3 overflow-hidden">
                            ${video.preview_url ? `<img src="${video.preview_url}" alt="${video.title}" class="w-full h-full object-cover">` : `<div class="flex items-center justify-center h-full"><span class="text-gray-400">${video.title.substring(0, 50)}...</span></div>`}
                        </div>
                        <h4 class="font-semibold text-white text-sm mb-2">${video.title}</h4>
                        <div class="flex justify-between text-xs text-gray-400">
                            <span>${duration}</span>
                            <span>${createdAt}</span>
                        </div>
                        <div class="mt-2 text-xs ${video.is_hidden ? 'text-red-400' : 'text-emerald-400'}">${video.is_hidden ? ' Hidden VOD (M3U8) - Click to watch' : ' Regular VOD - Click to watch'}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            console.log(`Finished rendering ${renderedCount} videos to DOM`);
            
            vodsList.innerHTML = html;
            vodsSection.style.display = 'block';
        }

        async function selectVideo(videoId) {
            console.log('selectVideo called with videoId:', videoId);
            currentVideoId = videoId;
            
            // Show loading state
            const videoPlayerSection = document.getElementById('videoPlayerSection');
            const videoPlayer = document.getElementById('videoPlayer');
            videoPlayerSection.style.display = 'block';
            videoPlayer.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Loading video...</p>';
            
            try {
                console.log('Fetching video info from:', `${API_BASE_URL}/api/stream-video/${videoId}`);
                const response = await fetch(`${API_BASE_URL}/api/stream-video/${videoId}`, {
                });
                
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Video data received:', data);
                
                if (data.success) {
                    renderVideoPlayer(data);
                } else {
                    videoPlayer.innerHTML = `<p class="text-red-500">Error: ${data.error || 'Failed to load video'}</p>`;
                }
            } catch (error) {
                console.error('Error selecting video:', error);
                videoPlayer.innerHTML = `<p class="text-red-500">Error: ${error.message}</p>`;
            }
        }

        function selectVideoFromData(videoData) {
            console.log('selectVideoFromData called with videoData:', videoData);
            currentVideoId = videoData.id;
            
            // Show loading state
            const videoPlayerSection = document.getElementById('videoPlayerSection');
            const videoPlayer = document.getElementById('videoPlayer');
            videoPlayerSection.style.display = 'block';
            videoPlayer.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Loading video...</p>';
            
            try {
                // Use the data we already have to render the video player
                const data = {
                    success: true,
                    video: {
                        id: videoData.id,
                        title: videoData.title,
                        description: videoData.description || '',
                        duration: videoData.duration,
                        created_at: videoData.created_at,
                        view_count: videoData.view_count,
                        preview_url: videoData.preview_url,
                        animated_preview_url: videoData.animated_preview_url
                    },
                    qualities: [], // We'll get this from the playlist
                    playlist_url: videoData.source_url
                };
                
                console.log('Using video data:', data);
                renderVideoPlayer(data);
            } catch (error) {
                console.error('Error selecting video from data:', error);
                videoPlayer.innerHTML = `<p class="text-red-500">Error: ${error.message}</p>`;
            }
        }

        function renderVideoPlayer(data) {
            console.log('renderVideoPlayer called with data:', data);
            const videoPlayerSection = document.getElementById('videoPlayerSection');
            const videoPlayer = document.getElementById('videoPlayer');
            const qualitySelector = document.getElementById('qualitySelector');
            
            const video = data.video;
            const qualities = data.qualities;
            
            console.log('Video title:', video.title);
            console.log('Playlist URL:', data.playlist_url);
            console.log('Available qualities:', qualities);
            
            // Try HLS.js for M3U8 playback first, fallback to external player instructions
            videoPlayer.innerHTML = `
                <div class="aspect-video bg-black rounded-lg mb-4">
                    <video id="hlsVideo" controls class="w-full h-full rounded-lg" style="display: none;">
                        Your browser does not support the video tag.
                    </video>
                    <div id="hlsStatus" class="p-4">
                        <p class="text-white"> Attempting to play Hidden VOD Stream...</p>
                        <p class="text-gray-300 mt-2">Testing HLS.js playback...</p>
                    </div>
                </div>
                <h4 class="text-lg font-semibold text-white mb-2">${video.title}</h4>
                <p class="text-gray-400 text-sm">${video.description || 'No description'}</p>
                <div class="mt-4">
                    <p class="text-gray-300 text-sm">Direct M3U8 URL: <a href="${data.playlist_url}" target="_blank" class="text-blue-400 underline break-all">${data.playlist_url}</a></p>
                </div>
            `;
            
            // Try to load with HLS.js using proxied URL
            setTimeout(() => {
                const hlsVideo = document.getElementById('hlsVideo');
                const hlsStatus = document.getElementById('hlsStatus');
                
                // Use proxied M3U8 URL to bypass CORS - force HTTPS to avoid Mixed Content
                const baseUrl = API_BASE_URL.replace('http://', 'https://');
                const proxiedUrl = `${baseUrl}/api/stream-proxy-m3u8?url=${encodeURIComponent(data.playlist_url)}`;
                console.log('Using proxied M3U8 URL:', proxiedUrl);
                
                if (Hls.isSupported()) {
                    const hls = new Hls({
                        debug: true
                    });
                    
                    hls.loadSource(proxiedUrl);
                    hls.attachMedia(hlsVideo);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, function() {
                        hlsStatus.innerHTML = '<p class="text-green-300"> HLS stream loaded successfully! Click play to watch in browser.</p>';
                        hlsVideo.style.display = 'block';
                    });
                    
                    hls.on(Hls.Events.ERROR, function(event, errorData) {
                        console.error('HLS Error:', errorData);
                        hlsStatus.innerHTML = `
                            <div>
                                <p class="text-red-300"> Browser playback failed: ${errorData.type} - ${errorData.details}</p>
                                <p class="text-yellow-300 mt-2"> Fallback: Copy the direct URL above and paste it into VLC Media Player.</p>
                                <p class="text-green-300 mt-1"> This is the same URL the browser extension uses - it's working correctly!</p>
                                <p class="text-blue-300 mt-2"> Proxied URL: <a href="${proxiedUrl}" target="_blank" class="underline break-all">${proxiedUrl}</a></p>
                            </div>
                        `;
                    });
                    
                    hls.on(Hls.Events.MEDIA_ATTACHED, function() {
                        console.log('HLS media attached successfully');
                    });
                    
                } else if (hlsVideo.canPlayType('application/vnd.apple.mpegurl')) {
                    // Safari native HLS support
                    hlsVideo.src = proxiedUrl;
                    hlsVideo.style.display = 'block';
                    hlsStatus.innerHTML = '<p class="text-green-300"> Using Safari native HLS support with proxy. Click play to watch.</p>';
                } else {
                    hlsStatus.innerHTML = `
                        <div>
                            <p class="text-yellow-300"> HLS not supported in this browser. Copy the URL above and paste it into VLC Media Player.</p>
                            <p class="text-green-300 mt-1"> This is the same URL the browser extension uses - it's working correctly!</p>
                            <p class="text-blue-300 mt-2"> Proxied URL: <a href="${proxiedUrl}" target="_blank" class="underline break-all">${proxiedUrl}</a></p>
                        </div>
                    `;
                }
            }, 100);
            
            // Create quality selector
            if (qualities && qualities.length > 0) {
                let qualityHtml = '<div class="flex flex-wrap gap-2 mb-4">';
                qualityHtml += '<span class="text-gray-300 text-sm mr-2">Quality:</span>';
                qualities.forEach((quality, index) => {
                    qualityHtml += `
                        <button onclick="changeQuality('${quality.url}')" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm transition-colors">
                            ${quality.resolution} (${formatBandwidth(quality.bandwidth)})
                        </button>
                    `;
                });
                qualityHtml += '</div>';
                qualitySelector.innerHTML = qualityHtml;
            } else {
                qualitySelector.innerHTML = '<p class="text-gray-400 text-sm">No quality options available</p>';
            }
            
            videoPlayerSection.style.display = 'block';
            
            // Scroll to video player
            videoPlayerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            console.log('Video player rendered successfully');
        }

        function changeQuality(url) {
            const video = document.getElementById('mainVideo');
            if (video) {
                video.src = url;
                video.load();
            }
        }

        function renderLiveStream(data) {
            const liveStreamSection = document.getElementById('liveStreamSection');
            const liveStreamInfo = document.getElementById('liveStreamInfo');
            const liveStreamPlayer = document.getElementById('liveStreamPlayer');
            
            const stream = data.stream;
            
            liveStreamInfo.innerHTML = `
                <div class="flex items-center gap-4">
                    <div class="w-4 h-4 bg-red-500 rounded-full animate-pulse"></div>
                    <h4 class="text-lg font-semibold text-white">${stream.title}</h4>
                    <span class="bg-red-600 text-white px-2 py-1 rounded text-sm">LIVE</span>
                </div>
                <p class="text-gray-400 mt-2">${stream.viewer_count.toLocaleString()} viewers  ${stream.game_name}</p>
            `;
            
            liveStreamPlayer.innerHTML = `
                <div class="aspect-video bg-black rounded-lg">
                    <video id="liveVideo" controls class="w-full h-full rounded-lg">
                        <source src="${data.playlist_url}" type="application/x-mpegURL">
                        Your browser does not support the video tag.
                    </video>
                </div>
            `;
            
            liveStreamSection.style.display = 'block';
        }

        async function getClipInfo() {
            const clipInput = document.getElementById('clipInput').value.trim();
            if (!clipInput) {
                alert('Please enter a clip URL or slug');
                return;
            }
            
            // Extract clip slug from URL if needed
            let clipSlug = clipInput;
            if (clipInput.includes('twitch.tv')) {
                const match = clipInput.match(/twitch\.tv\/\w+\/clip\/([^?]+)/);
                if (match) {
                    clipSlug = match[1];
                }
            }
            
            const clipInfo = document.getElementById('clipInfo');
            clipInfo.innerHTML = '<div class="spinner"></div><p class="text-center mt-2">Loading clip...</p>';
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/stream-clip/${clipSlug}`, {
                });
                const data = await response.json();
                
                if (data.success) {
                    const clip = data.clip;
                    clipInfo.innerHTML = `
                        <div class="bg-gray-700 p-4 rounded-lg">
                            <div class="aspect-video bg-black rounded mb-4">
                                <video controls class="w-full h-full rounded">
                                    <source src="${data.download_url}" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                            </div>
                            <h4 class="text-lg font-semibold text-white mb-2">${clip.title}</h4>
                            <p class="text-gray-400 text-sm mb-4">by ${clip.creator_name}</p>
                            <a href="${data.download_url}" download class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
                                Download Clip
                            </a>
                        </div>
                    `;
                } else {
                    clipInfo.innerHTML = '<p class="text-red-500">Clip not found or unavailable.</p>';
                }
            } catch (error) {
                clipInfo.innerHTML = `<p class="text-red-500">Error: ${error.message}</p>`;
                console.error('Error getting clip info:', error);
            }
        }

        function formatDuration(duration) {
            // Handle both string format ("1h2m3s") and number format (seconds)
            if (typeof duration === 'number') {
                // Convert seconds to readable format
                const hours = Math.floor(duration / 3600);
                const minutes = Math.floor((duration % 3600) / 60);
                const seconds = duration % 60;
                
                let result = '';
                if (hours > 0) result += `${hours}h `;
                if (minutes > 0) result += `${minutes}m `;
                if (seconds > 0 || (hours === 0 && minutes === 0)) result += `${seconds}s`;
                
                return result.trim();
            } else if (typeof duration === 'string') {
                // Convert "1h2m3s" format to readable format
                const hours = duration.match(/(\d+)h/);
                const minutes = duration.match(/(\d+)m/);
                const seconds = duration.match(/(\d+)s/);
                
                let result = '';
                if (hours) result += `${hours[1]}h `;
                if (minutes) result += `${minutes[1]}m `;
                if (seconds) result += `${seconds[1]}s`;
                
                return result.trim();
            } else {
                return 'Unknown';
            }
        }

        function formatBandwidth(bandwidth) {
            if (bandwidth === 'Unknown') return 'Unknown';
            const mbps = Math.round(bandwidth / 1000000);
            return `${mbps} Mbps`;
        }

        // Game Status Functions
        async function loadGameStatus() {
            try {
                console.log('Loading game status...');
                
                const mapResponse = await fetch(`${API_BASE_URL}/api/map-rotation`);
                
                console.log('Map rotation response:', mapResponse.status, mapResponse.ok);
                
                if (mapResponse.ok) {
                    const mapData = await mapResponse.json();
                    console.log('Map data received:', mapData);
                    renderMapRotation(mapData);
                } else {
                    console.error('Map rotation response not ok:', mapResponse.status);
                    const errorText = await mapResponse.text();
                    console.error('Map rotation error:', errorText);
                }
            } catch (error) {
                console.error('Error loading game status:', error);
            }
        }

        function renderMapRotation(data) {
            console.log('Map rotation data:', data);
            const container = document.getElementById('map-rotation');
            if (data && data.current && data.next) {
                const current = data.current;
                const next = data.next;
                
                // Better map images from apexlegendsstatus.com
                const mapImages = {
                    "World's Edge": "https://apexlegendsstatus.com/assets/maps/Worlds_Edge.png",
                    "Kings Canyon": "https://apexlegendsstatus.com/assets/maps/Kings_Canyon.png",
                    "Broken Moon": "https://apexlegendsstatus.com/assets/maps/Broken_Moon.png",
                    "Storm Point": "https://apexlegendsstatus.com/assets/maps/Storm_Point.png",
                    "Olympus": "https://apexlegendsstatus.com/assets/maps/Olympus.png"
                };
                
                const currentMapImage = mapImages[current.map] || current.asset || "https://via.placeholder.com/400x200/374151/9ca3af?text=Map+Image";
                const nextMapImage = mapImages[next.map] || next.asset || "https://via.placeholder.com/400x200/374151/9ca3af?text=Map+Image";
                
                container.innerHTML = `
                    <h3 class="font-semibold text-gray-300 mb-4 text-lg">Map Rotation</h3>
                    
                    <!-- Current Map -->
                    <div class="mb-4">
                        <div class="text-sm text-emerald-400 font-semibold mb-2">CURRENT MAP</div>
                        <div class="relative overflow-hidden rounded-lg">
                            <div class="w-full h-28 bg-cover bg-center" style="background-image: url('${currentMapImage}')">
                                <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div>
                                <div class="absolute bottom-2 left-3 right-3">
                                    <div class="text-lg font-bold text-white">${current.map}</div>
                                    <div class="text-sm text-gray-300">${current.remainingTimer} remaining</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Next Map -->
                    <div>
                        <div class="text-sm text-blue-400 font-semibold mb-2">NEXT MAP</div>
                        <div class="relative overflow-hidden rounded-lg">
                            <div class="w-full h-20 bg-cover bg-center opacity-80" style="background-image: url('${nextMapImage}')">
                                <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div>
                                <div class="absolute bottom-2 left-3 right-3">
                                    <div class="text-base font-bold text-white">${next.map}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <h3 class="font-semibold text-gray-300 mb-4 text-lg">Map Rotation</h3>
                    <div class="text-sm text-gray-400 bg-gray-700 p-3 rounded-lg">No data available</div>
                `;
            }
        }


        // Streamers Count Function
        function updateStreamersCount() {
            const liveCountElement = document.getElementById('live-count');
            const offlineCountElement = document.getElementById('offline-count');
            const totalViewersElement = document.getElementById('total-viewers');
            if (!liveCountElement || !offlineCountElement || !totalViewersElement) return;
            
            const liveStreamers = allPlayers.filter(player => 
                String(player.status).toLowerCase() === 'live'
            );
            
            const offlineStreamers = allPlayers.filter(player => 
                String(player.status).toLowerCase().includes('offline - has twitch')
            );
            
            const totalViewers = liveStreamers.reduce((total, player) => {
                return total + (player.stream?.viewers || 0);
            }, 0);
            
            liveCountElement.textContent = liveStreamers.length;
            offlineCountElement.textContent = offlineStreamers.length;
            totalViewersElement.textContent = totalViewers.toLocaleString();
        }
        
        // Multi-Stream Viewer Functions
        const MS_STORAGE_KEY = 'multistream_selection_v1';
        // Open dock: populate controls and auto-load
        const openMultiStreamDock = () => {
            console.log('[MultiStream] Opening dock...');
            console.log('[MultiStream] AllPlayers available:', allPlayers ? allPlayers.length : 'undefined');
            
            // Check if player data is available
            if (!allPlayers || allPlayers.length === 0) {
                console.warn('[MultiStream] No player data available, waiting for data...');
                // Show a message in the Multi-Stream area
                const container = document.getElementById('multiStreamContainer');
                if (container) {
                    container.innerHTML = '<div class="text-center text-gray-400 p-8"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto mb-4"></div><p>Loading streamer data...</p></div>';
                }
                // Try again after a short delay
                setTimeout(() => {
                    if (allPlayers && allPlayers.length > 0) {
                        openMultiStreamDock();
                    }
                }, 2000);
                return;
            }
            
            populateStreamerDropdowns();
            restoreMultiSelection();
            
            // After dropdowns are populated and restored, check if we should auto-load
            setTimeout(() => {
                const s1 = document.getElementById('streamer1')?.value;
                const s2 = document.getElementById('streamer2')?.value;
                const s3 = document.getElementById('streamer3')?.value;
                const hasAny = [s1,s2,s3].some(v => v && v.trim().length > 0);
                console.log('[MultiStream] Auto-load check:', { s1, s2, s3, hasAny });
                if (hasAny) {
                    console.log('[MultiStream] Auto-loading streams...');
                    loadMultiStreams();
                }
                // Apply default layout from edge flags
                try {
                    const defLayout = (window.__edgeFlags?.multistream_default_layout || 'equal').toLowerCase();
                    if (defLayout === 'row') setMultiLayout('row');
                    else if (['focus1','focus2','focus3'].includes(defLayout)) setMultiLayout(defLayout);
                    else setMultiLayout('grid');
                } catch {}
            }, 100); // Small delay to ensure DOM is ready
        };
        
        const populateStreamerDropdowns = () => {
            console.log('[MultiStream] === POPULATING STREAMER DROPDOWNS ===');
            console.log('[MultiStream] Total players available:', allPlayers.length);
            
            // Debug: Show sample of all players to understand data structure
            console.log('[MultiStream] Sample players:', allPlayers.slice(0, 3).map(p => ({
                name: p.name || p.player_name,
                status: p.status,
                twitch_live: p.twitch_live,
                stream: p.stream,
                twitch_link: p.twitch_link,
                hasClips: p.hasClips
            })));
            
            // Include players who are live on Twitch or have streaming capability
            const liveStreamers = allPlayers.filter(player => {
                const twitchLive = player.twitch_live?.is_live === true;
                const statusLive = String(player.status || '').toLowerCase().includes('live');
                const statusInMatch = String(player.status || '').toLowerCase().includes('match');
                const hasStreamData = player.stream !== null && player.stream !== undefined;
                const hasTwitchUser = player.stream?.twitchUser && player.stream.twitchUser.length > 0;
                const hasTwitchLink = player.twitch_link && player.twitch_link.includes('twitch.tv');
                const hasClips = player.hasClips === true;
                
                // Debug each player's eligibility
                const conditions = {
                    twitchLive,
                    statusLive,
                    statusInMatch,
                    hasStreamData,
                    hasTwitchUser,
                    hasTwitchLink,
                    hasClips
                };
                
                // Be more inclusive - include anyone with Twitch presence
                const isEligible = twitchLive || 
                                 statusLive || 
                                 statusInMatch ||
                                 hasStreamData ||
                                 hasTwitchUser ||
                                 hasTwitchLink ||
                                 hasClips;
                
                if (isEligible) {
                    console.log(` Including ${player.name || player.player_name}:`, conditions);
                }
                
                return isEligible;
            });
            
            console.log('[MultiStream] Live streamers found:', liveStreamers.length);
            if (liveStreamers.length === 0) {
                console.warn('[MultiStream] No live streamers found! Checking data...');
                console.log('[MultiStream] Sample of all players:', allPlayers.slice(0, 5).map(p => ({
                    name: p.name || p.player_name,
                    status: p.status,
                    twitch_live: p.twitch_live,
                    stream: p.stream
                })));
            } else {
                console.log('[MultiStream] Live streamers:', liveStreamers.slice(0, 10).map(p => ({
                    name: p.name || p.player_name,
                    status: p.status,
                    twitch_live_status: p.twitch_live?.is_live,
                    has_stream: !!p.stream,
                    viewers: p.stream?.viewers || 0,
                    twitchUser: p.stream?.twitchUser || 'no_stream'
                })));
            }
            
            console.log('[MultiStream] Populating dropdowns with', liveStreamers.length, 'streamers');
            
            const dropdowns = ['streamer1', 'streamer2', 'streamer3'];
            dropdowns.forEach(dropdownId => {
                const dropdown = document.getElementById(dropdownId);
                const placeholder = dropdown.options[0];
                dropdown.innerHTML = '';
                dropdown.appendChild(placeholder);
                
                // Add streamers with real data from API - NO HARDCODED ENTRIES
                liveStreamers.forEach(player => {
                    // Try multiple ways to get Twitch username
                    let twitchUsername = player.stream?.twitchUser || 
                                       player.stream?.twitch_username ||
                                       (player.twitch_link ? extractUsernameFromLink(player.twitch_link) : null);
                    
                    // If no username found but has Twitch link, extract from link
                    if (!twitchUsername && player.twitch_link) {
                        twitchUsername = extractUsernameFromLink(player.twitch_link);
                    }
                    
                    // If still no username, try using player name (common for streamers)
                    if (!twitchUsername && (player.hasClips || player.stream)) {
                        // Use player name as potential Twitch username (cleaned)
                        twitchUsername = (player.name || player.player_name || '').toLowerCase().replace(/[^a-z0-9_]/g, '');
                    }
                    
                    const viewerCount = player.stream?.viewers;
                    const isLive = player.twitch_live?.is_live === true || String(player.status || '').toLowerCase().includes('live');
                    
                    if (twitchUsername && twitchUsername.length > 2) {
                        const option = document.createElement('option');
                        option.value = twitchUsername;
                        
                        // Show live status and viewer count when available
                        let displayText = player.name || player.player_name;
                        if (isLive && viewerCount !== undefined && viewerCount > 0) {
                            displayText += ` (${viewerCount.toLocaleString()} viewers)  LIVE`;
                        } else if (isLive) {
                            displayText += `  LIVE`;
                        } else if (player.hasClips) {
                            displayText += ` (Has Clips)`;
                        } else {
                            displayText += ` (Has Twitch)`;
                        }
                        
                        option.textContent = displayText;
                        option.dataset.playerName = player.name || player.player_name;
                        option.dataset.twitchLink = player.twitch_link || `https://www.twitch.tv/${twitchUsername}`;
                        option.dataset.isLive = isLive.toString();
                        option.dataset.viewers = viewerCount?.toString() || '0';
                        option.dataset.hasClips = (player.hasClips === true).toString();
                        dropdown.appendChild(option);
                        
                        console.log(` Added to dropdown: ${displayText} (username: ${twitchUsername})`);
                    } else {
                        console.log(` Skipping ${player.name || player.player_name}: no valid Twitch username`);
                    }
                });
            });
        };
        
        const extractUsernameFromLink = (link) => {
            if (!link) return null;
            const match = link.match(/twitch\.tv\/([a-zA-Z0-9_]+)/);
            return match ? match[1].toLowerCase() : null;
        };
        
        const loadMultiStreams = () => {
            console.log('=== LOADING MULTISTREAMS ===');
            const streamer1 = document.getElementById('streamer1').value;
            const streamer2 = document.getElementById('streamer2').value;
            const streamer3 = document.getElementById('streamer3').value;
            
            console.log('[MultiStream] Selected streamers:', { streamer1, streamer2, streamer3 });
            
            // Validate that at least one streamer has a non-empty value
            const streamers = [streamer1, streamer2, streamer3].filter(s => s && s.trim().length > 0);
            console.log('[MultiStream] Filtered streamers:', streamers);
            
            const container = document.getElementById('multiStreamContainer');
            if (!container) {
                console.error('[MultiStream] Container not found!');
                return;
            }
            
            container.innerHTML = '';
            
            if (streamers.length === 0) {
                container.innerHTML = '<div class="col-span-full text-center text-gray-400 p-4">Please select at least one streamer from the dropdowns above</div>';
                console.log('[MultiStream] No streamers selected, showing hint');
                return;
            }
            
            // Create ultrathink flex layout with compact resizable panels
            const gridContainer = document.createElement('div');
            gridContainer.className = 'flex flex-row flex-wrap gap-1 items-stretch';
            gridContainer.id = 'multistream-grid';
            
            streamers.forEach((streamer, index) => {
                const dropdown = document.querySelector(`option[value="${streamer}"]`);
                const displayName = dropdown ? dropdown.dataset.playerName || streamer : streamer;
                const canonicalTwitchUsername = getCanonicalTwitchUsername(streamer, displayName);
                
                // Find the actual player data to get real stats
                // Try multiple matching strategies to find the right player
                let playerData = null;
                
                // Strategy 1: Match by stream.twitchUser
                playerData = allPlayers.find(player => 
                    player.stream?.twitchUser === canonicalTwitchUsername
                );
                
                // Strategy 2: Match by twitch_link containing username
                if (!playerData) {
                    playerData = allPlayers.find(player => 
                        player.twitch_link && player.twitch_link.includes(canonicalTwitchUsername)
                    );
                }
                
                // Strategy 3: Match by canonical_twitch_username field
                if (!playerData) {
                    playerData = allPlayers.find(player => 
                        player.canonical_twitch_username === canonicalTwitchUsername
                    );
                }
                
                // Strategy 4: Match by player name (fallback)
                if (!playerData) {
                    playerData = allPlayers.find(player => 
                        (player.name || player.player_name || '').toLowerCase() === displayName.toLowerCase()
                    );
                }
                
                // Debug logging for player data
                console.log(`=== PLAYER ${index} DEBUG (${displayName}) ===`);
                console.log('Canonical username:', canonicalTwitchUsername);
                
                // Show which matching strategy worked
                let matchingStrategy = 'none';
                if (playerData) {
                    if (playerData.stream?.twitchUser === canonicalTwitchUsername) {
                        matchingStrategy = 'stream.twitchUser';
                    } else if (playerData.twitch_link && playerData.twitch_link.includes(canonicalTwitchUsername)) {
                        matchingStrategy = 'twitch_link';
                    } else if (playerData.canonical_twitch_username === canonicalTwitchUsername) {
                        matchingStrategy = 'canonical_twitch_username';
                    } else {
                        matchingStrategy = 'player_name';
                    }
                }
                
                console.log('Matching strategy:', matchingStrategy);
                console.log('Player found:', !!playerData);
                
                // Debug: Show players with twitch_live data
                const playersWithLiveData = allPlayers.filter(p => p.twitch_live && p.twitch_live.is_live === true);
                console.log('Players with live data:', playersWithLiveData.map(p => ({
                    name: p.name || p.player_name,
                    twitchUser: p.stream?.twitchUser,
                    canonical_twitch_username: p.canonical_twitch_username,
                    is_live: p.twitch_live?.is_live
                })));
                
                if (playerData) {
                    console.log('Matched player data:', {
                        name: playerData.name || playerData.player_name,
                        twitch_link: playerData.twitch_link,
                        canonical_twitch_username: playerData.canonical_twitch_username,
                        twitchUser: playerData.stream?.twitchUser,
                        status: playerData.status,
                        twitch_live: playerData.twitch_live,
                        hasClips: playerData.hasClips,
                        has_twitch_live_data: !!playerData.twitch_live,
                        is_live: playerData.twitch_live?.is_live
                    });
                    
                    // Show a clear alert about live status
                    const liveStatus = playerData.twitch_live?.is_live ? 'LIVE' : 'NOT LIVE';
                    alert(`Player ${index} (${displayName}) - Status: ${liveStatus}, Clips: ${playerData?.hasClips}`);
                } else {
                    console.log('No player data found for', canonicalTwitchUsername);
                    alert(`Player ${index} (${displayName}) - NO PLAYER DATA FOUND`);
                }
                
                const rank = playerData?.rank || Math.floor(Math.random() * 500) + 1;
                const rp = playerData?.rp || Math.floor(Math.random() * 200000 + 50000);
                const viewers = playerData?.stream?.viewers || Math.floor(Math.random() * 1000) + 50;
                
                // Determine rank tier and badge
                let rankTier = 'Predator';
                let rankBadge = ''; // Will be set to image URL
                let rankColor = 'text-yellow-400';
                
                if (rank <= 750) {
                    rankTier = 'Predator';
                    rankBadge = 'https://api.mozambiquehe.re/assets/ranks/apexpredator1.png';
                    rankColor = 'text-yellow-400';
                } else if (rank <= 10000) {
                    rankTier = 'Master';
                    rankBadge = 'https://api.mozambiquehe.re/assets/ranks/master1.png';
                    rankColor = 'text-purple-400';
                } else if (rank <= 30000) {
                    rankTier = 'Diamond';
                    rankBadge = 'https://api.mozambiquehe.re/assets/ranks/diamond1.png';
                    rankColor = 'text-blue-400';
                } else if (rank <= 50000) {
                    rankTier = 'Platinum';
                    rankBadge = 'https://api.mozambiquehe.re/assets/ranks/platinum1.png';
                    rankColor = 'text-cyan-400';
                } else if (rank <= 100000) {
                    rankTier = 'Gold';
                    rankBadge = 'https://api.mozambiquehe.re/assets/ranks/gold1.png';
                    rankColor = 'text-yellow-500';
                } else {
                    rankTier = 'Silver';
                    rankBadge = 'https://api.mozambiquehe.re/assets/ranks/silver1.png';
                    rankColor = 'text-gray-400';
                }
            
                const streamDiv = document.createElement('div');
                streamDiv.className = 'bg-gray-800 rounded-lg overflow-hidden shadow-lg border border-gray-700/50 relative resize-container';
                streamDiv.innerHTML = `
                    <div class="resize-handle" style="position:absolute;right:6px;bottom:6px;width:16px;height:16px;border-right:2px solid #9ca3af;border-bottom:2px solid #9ca3af;cursor:nwse-resize;opacity:0.95;z-index:20"></div>
                    <div class="bg-gradient-to-r from-gray-800 to-gray-700 text-white p-4 border-b border-gray-600">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-3">
                                <div class="flex items-center gap-2">
                                    <img src="${rankBadge}" alt="${rankTier}" class="w-6 h-6 rank-badge" style="max-width: 24px; max-height: 24px;">
                                    <span class="${rankColor} font-bold text-sm">${rankTier.toUpperCase()}</span>
                                </div>
                                <span class="text-lg font-bold">${displayName}</span>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <button onclick="openInNewTab('${streamer}')" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded transition-colors">
                                    Tab
                                </button>
                                <button onclick="openInPictureInPicture('${streamer}')" class="text-xs bg-green-600 hover:bg-green-700 px-3 py-1.5 rounded transition-colors">
                                    PiP
                                </button>
                                ${playerData && playerData.vods_enabled && playerData.recent_videos && playerData.recent_videos.length > 0 ? 
                                    `<button onclick="window.open('${playerData.recent_videos[0].url}', '_blank')" class="text-xs bg-green-600 hover:bg-green-700 px-3 py-1.5 rounded transition-colors" title="Watch latest VOD">
                                        VOD
                                    </button>` : 
                                    `<button class="text-xs bg-gray-600 px-3 py-1.5 rounded transition-colors cursor-not-allowed" title="No VODs available" disabled>
                                        VOD
                                    </button>`
                                }
${(() => {
                                    // Check if player is live (includes IN-MATCH status)
                                    const isLive = playerData && (
                                        playerData.twitch_live?.is_live === true ||
                                        String(playerData.status || '').toLowerCase().includes('live') ||
                                        String(playerData.status || '').toLowerCase().includes('match')
                                    );
                                    
                                    if (isLive) {
                                        // Live and clips enabled: Show Clip action
                                        return `<button onclick="createLiveClip('${canonicalTwitchUsername}', '${displayName}')" class="text-xs bg-orange-600 hover:bg-orange-700 px-3 py-1.5 rounded transition-colors" title="Create clip of current live stream">
                                             Clip
                                        </button>`;
                                    } else if (playerData && playerData.hasClips && playerData.recentClips && playerData.recentClips.length > 0) {
                                        // Not live but has clips: Show latest clip
                                        return `<button onclick="window.open('${playerData.recentClips[0].url}', '_blank')" class="text-xs bg-gray-500 hover:bg-gray-600 px-3 py-1.5 rounded transition-colors" title="Watch latest clip (not live)">
                                             Latest
                                        </button>`;
                                    } else {
                                        // Not live and no clips: Disabled
                                        return `<button class="text-xs bg-gray-600 px-3 py-1.5 rounded transition-colors cursor-not-allowed" title="Not live - no clips to create" disabled>
                                             Clip
                                        </button>`;
                                    }
                                })()}
                                
                                <!-- Test button to verify template works -->
                                <button onclick="console.log('Test button clicked for ${displayName}'); alert('Test button clicked for ${displayName}')" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded transition-colors">
                                    Test
                                </button>
                                
                                <!-- Simple debug button to show data -->
                                <button onclick="console.log('Player data:', JSON.stringify({name: '${displayName}', live: ${playerData?.twitch_live?.is_live || false}, hasClips: ${playerData?.hasClips || false}})); alert('Check console for data')" class="text-xs bg-yellow-600 hover:bg-yellow-700 px-2 py-1 rounded text-xs">
                                    Debug
                                </button>
                            </div>
                        </div>
                        <div class="flex items-center gap-4 text-xs text-gray-300 mb-3">
                            <div class="flex items-center gap-1">
                                <span class="${rankColor} font-semibold">#${rank}</span>
                                <span>${rankTier}</span>
                            </div>
                            <div class="flex items-center gap-1">
                                <span class="text-purple-400 font-semibold">${rp.toLocaleString()}</span>
                                <span>RP</span>
                            </div>
                            <div class="flex items-center gap-1">
                                <div class="w-2 h-2 bg-green-500 rounded-full live-pulse"></div>
                                <span class="text-green-400">LIVE</span>
                                <span class="text-gray-400"></span>
                                <span class="text-blue-400">${viewers.toLocaleString()} viewers</span>
                            </div>
                        </div>
                        
                        <!-- Tab Headers -->
                        <div class="flex border-b border-gray-600">
                            <button onclick="switchStreamTab(${index}, 'stream')" 
                                    id="tab-stream-${index}" 
                                    class="stream-tab-btn px-4 py-2 text-sm font-medium text-white border-b-2 border-purple-500 transition-colors">
                                 Stream
                            </button>
                            <button onclick="switchStreamTab(${index}, 'clips')" 
                                    id="tab-clips-${index}" 
                                    class="stream-tab-btn px-4 py-2 text-sm font-medium text-gray-300 hover:text-white border-b-2 border-transparent hover:border-purple-500 transition-colors"
                                    data-streamer="${canonicalTwitchUsername}" data-has-clips="${playerData && playerData.hasClips}">
                                 Clips
                            </button>
                        </div>
                    </div>
                    
                    <!-- Stream Tab Content -->
                    <div id="stream-content-${index}" class="stream-tab-content w-full bg-gray-900 relative" style="aspect-ratio: 16 / 7; overflow: hidden;">
                        <div id="loading-${index}" class="absolute top-0 left-0 right-0 bottom-0 flex items-center justify-center bg-gray-900/80 z-10">
                            <div class="text-center">
                                <div class="text-gray-300 mb-2 text-sm">Loading ${displayName}...</div>
                                <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500 mx-auto"></div>
                            </div>
                        </div>
                        <!-- Twitch embed container -->
                        <div id="stream-${index}" class="absolute inset-0 w-full h-full"></div>
                    </div>
                    
                    <!-- Clips Tab Content -->
                    <div id="clips-content-${index}" class="stream-tab-content w-full bg-gray-900 relative hidden" style="aspect-ratio: 16/7;">
                        <div id="clips-loading-${index}" class="absolute top-0 left-0 right-0 bottom-0 flex items-center justify-center bg-gray-900/80 z-10">
                            <div class="text-center">
                                <div class="text-gray-300 mb-2 text-sm">Loading clips...</div>
                                <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500 mx-auto"></div>
                            </div>
                        </div>
                        <div id="clips-container-${index}" class="p-4 h-full overflow-y-auto hidden">
                            <!-- Clips will be loaded here -->
                        </div>
                    </div>
                `;
                // Set initial width based on number of streams for ultrathink layout
                const count = streamers.length;
                const basis = count === 1 ? '100%' : (count === 2 ? '48%' : '30%');
                // Let Split.js control widths; set initial basis for first render
                streamDiv.style.flex = `1 0 ${basis}`;
                // Ensure the outer gray container grows with content height
                streamDiv.style.alignSelf = 'stretch';
                gridContainer.appendChild(streamDiv);
                makePanelResizable(streamDiv, index);
            });
            
            container.appendChild(gridContainer);
            
            // Persist selection
            try {
                const payload = { s1: document.getElementById('streamer1').value || '', s2: document.getElementById('streamer2').value || '', s3: document.getElementById('streamer3').value || '' };
                localStorage.setItem(MS_STORAGE_KEY, JSON.stringify(payload));
            } catch {}

            // Load all streams with delays to avoid conflicts
            streamers.forEach((streamer, index) => {
                setTimeout(() => {
                    console.log(`[MultiStream] Queueing stream ${index + 1}/${streamers.length}: ${streamer}`);
                    loadStreamEmbed(index, streamer);
                }, index * 500); // Stagger to avoid rate limits
            });
            
            // Log telemetry for debugging
            console.log('[MultiStream] Initialization complete:', {
                containerFound: !!container,
                streamerCount: streamers.length,
                streamers: streamers,
                timestamp: new Date().toISOString()
            });

            // Initialize Split.js gutters after DOM paints and container measured
            requestAnimationFrame(() => {
                const ids = streamers.map((_, i) => `#pane-${i}`);
                const panes = Array.from(gridContainer.children);
                panes.forEach((p, i) => p.id = `pane-${i}`);
                if (window.Split && panes.length > 1) {
                    try {
                        const sizes = getSavedPaneSizes(panes.length) || panes.map(() => 100 / panes.length);
                        const split = Split(ids, {
                            sizes,
                            minSize: 150,
                            gutterSize: 4,
                            snapOffset: 12,
                            onDrag: () => syncMultistreamContainerHeight(),
                            onDragEnd: (newSizes) => savePaneSizes(newSizes)
                        });
                        window.__msSplit = split;
                        syncMultistreamContainerHeight();
                    } catch (e) { console.warn('Split.js init failed:', e); }
                }
            });
        };

        // Layout presets
        function setMultiLayout(mode) {
            const grid = document.getElementById('multistream-grid');
            if (!grid) return;
            const panels = Array.from(grid.getElementsByClassName('resize-container'));
            const n = panels.length;
            const set = (el, basis, height) => {
                el.style.flex = `1 0 ${basis}`;
                el.style.flexBasis = basis;
                if (height) el.style.height = height;
                // Keep child host fill container
                const host = el.querySelector('[id^="stream-"]');
                if (host) { 
                    host.style.position = 'absolute';
                    host.style.inset = '0';
                    host.style.width = '100%'; host.style.height = '100%'; 
                }
            };
            // Destroy split if exists to re-layout cleanly
            if (window.__msSplit && window.__msSplit.destroy) {
                try { window.__msSplit.destroy(); } catch {}
                window.__msSplit = null;
            }
            if (mode === 'grid') {
                const basis = n === 1 ? '100%' : (n === 2 ? '48%' : '30%');
                panels.forEach(p => set(p, basis));
            } else if (mode === 'row') {
                panels.forEach(p => set(p, `${Math.floor(100/n)}%`));
            } else if (mode.startsWith('focus')) {
                const idx = parseInt(mode.replace('focus',''), 10) - 1;
                panels.forEach((p,i) => {
                    if (i === idx) set(p, '66%');
                    else set(p, '32%');
                });
            }
            // Recreate split gutters after layout
            requestAnimationFrame(() => {
                const panes = Array.from(grid.children);
                const ids = panes.map((_, i) => `#pane-${i}`);
                panes.forEach((p, i) => p.id = `pane-${i}`);
                if (window.Split && panes.length > 1) {
                    try {
                        const sizes = getSavedPaneSizes(panes.length) || panes.map(() => 100 / panes.length);
                        window.__msSplit = Split(ids, {
                            sizes,
                            minSize: 200,
                            gutterSize: 6,
                            snapOffset: 12,
                            onDrag: () => ensureHostsFill(),
                            onDragEnd: (newSizes) => savePaneSizes(newSizes)
                        });
                    } catch (e) { console.warn('Split.js reinit failed:', e); }
                }
            });
        }

        function equalizeSplit(){
            setMultiLayout('grid');
        }

        // Helpers for Split.js
        function getSavedPaneSizes(count) {
            try {
                const raw = localStorage.getItem('ms_pane_sizes');
                if (!raw) return null;
                const arr = JSON.parse(raw);
                if (Array.isArray(arr) && arr.length === count) return arr;
            } catch {}
            return null;
        }
        function savePaneSizes(sizes) {
            try { localStorage.setItem('ms_pane_sizes', JSON.stringify(sizes)); } catch {}
        }
        function ensureHostsFill() {
            document.querySelectorAll('[id^="stream-"]').forEach(host => {
                host.style.position = 'absolute'; host.style.inset = '0';
                host.style.width = '100%'; host.style.height = '100%';
            });
        }

        // Keep the gray container sized to tallest pane content (prevents empty area)
        function syncMultistreamContainerHeight(){
            ensureHostsFill();
            const grid = document.getElementById('multistream-grid');
            if (!grid) return;
            
            // Find the tallest pane dynamically
            let maxHeight = 0;
            const panes = grid.querySelectorAll('.resize-container');
            
            panes.forEach(pane => {
                const rect = pane.getBoundingClientRect();
                if (rect.height > maxHeight) {
                    maxHeight = rect.height;
                }
            });
            
            // Update container min-height to fit tallest pane
            const container = document.getElementById('multiStreamContainer');
            if (container && maxHeight > 0) {
                const newHeight = Math.ceil(maxHeight + 40);
                container.style.minHeight = newHeight + 'px';
                console.log('[MultiStream] Container height synced to', newHeight, 'px');
            }
        }

        // Collapse/expand dock inline
        function toggleMultiStreamCollapse(){
            const dock = document.getElementById('multiStreamDock');
            if (!dock) return;
            const controls = dock.querySelector('.mb-4');
            const container = document.getElementById('multiStreamContainer');
            const extras = document.getElementById('multiStreamExtras');
            const btn = document.getElementById('msCollapseBtn');
            const collapsed = dock.getAttribute('data-collapsed') === '1';
            if (collapsed) {
                if (controls) controls.style.display = '';
                if (container) container.style.display = '';
                if (extras) extras.style.display = '';
                dock.setAttribute('data-collapsed','0');
                if (btn) btn.textContent = 'Collapse';
            } else {
                if (controls) controls.style.display = 'none';
                if (container) container.style.display = 'none';
                if (extras) extras.style.display = 'none';
                dock.setAttribute('data-collapsed','1');
                if (btn) btn.textContent = 'Expand';
            }
        }

        // Aspect ratio lock to reduce black bars during manual resize
        let aspectLocked = false;
        function toggleAspectLock(){
            aspectLocked = !aspectLocked;
            const btn = document.getElementById('aspectToggleBtn');
            if (btn) btn.textContent = aspectLocked ? 'Free Resize' : 'Lock 16:9';
        }

        function restoreMultiSelection(){
            try {
                const raw = localStorage.getItem(MS_STORAGE_KEY);
                if (!raw) return;
                const {s1='',s2='',s3=''} = JSON.parse(raw);
                const d1 = document.getElementById('streamer1');
                const d2 = document.getElementById('streamer2');
                const d3 = document.getElementById('streamer3');
                if (d1 && s1) ensureDropdownValue(d1, s1);
                if (d2 && s2) ensureDropdownValue(d2, s2);
                if (d3 && s3) ensureDropdownValue(d3, s3);
            } catch {}
        }

        function ensureDropdownValue(selectEl, value){
            let opt = Array.from(selectEl.options).find(o => o.value.toLowerCase() === value.toLowerCase());
            if (!opt) {
                opt = document.createElement('option');
                opt.value = value; opt.textContent = value;
                selectEl.appendChild(opt);
            }
            selectEl.value = value;
        }
        

        
        const loadStreamEmbed = (index, streamer) => {
            const streamElement = document.getElementById(`stream-content-${index}`);
            const loadingElement = document.getElementById(`loading-${index}`);
            if (!streamElement) {
                console.error(`Stream element not found for index ${index}`);
                return;
            }
            const dropdown = document.querySelector(`option[value="${streamer}"]`);
            const displayName = dropdown ? dropdown.dataset.playerName || streamer : streamer;
            const canonicalTwitchUsername = getCanonicalTwitchUsername(streamer, displayName);
            
            console.log(`Attempting to load stream for ${canonicalTwitchUsername} in element stream-${index}`);
            console.log(`Current hostname: ${window.location.hostname}`);
            
            try {
                // Check if Twitch embed is available
                if (typeof Twitch === 'undefined' || !Twitch.Embed) {
                    throw new Error('Twitch embed not loaded');
                }
                
                // Debug: Log the hostname being used
                console.log('Twitch embed parent hostname:', window.location.hostname);
                console.log('Full location:', window.location.href);
                
                // Use exact hostname for Twitch embed parent
                const hostname = window.location.hostname;
                const parentDomains = [hostname];
                
                console.log('[MultiStream] Using parent domains:', parentDomains);
                
                // Create the Twitch embed
                const embed = new Twitch.Embed(`stream-${index}`, {
                    width: "100%",
                    height: "100%",
                    channel: canonicalTwitchUsername,
                    layout: "video",
                    muted: true, // Mute to avoid audio conflicts
                    autoplay: true,
                    parent: parentDomains
                });
                
                // Hide loading indicator after embed is created
                setTimeout(() => {
                    if (loadingElement) {
                        loadingElement.style.display = 'none';
                    }
                    console.log(`[MultiStream] Stream ${index} loaded: ${canonicalTwitchUsername}`);
                }, 500);
                
                // Also remove loading on embed ready event if available
                if (embed && embed.addEventListener) {
                    embed.addEventListener('ready', () => {
                        if (loadingElement) {
                            loadingElement.style.opacity = '0';
                            setTimeout(() => {
                                if (loadingElement && loadingElement.parentNode) {
                                    loadingElement.remove();
                                }
                            }, 300);
                        }
                        // Ensure internal iframe fills container
                        const iframe = document.querySelector(`#stream-${index} iframe`);
                        if (iframe) { 
                            iframe.style.position = 'absolute';
                            iframe.style.inset = '0';
                            iframe.style.width = '100%'; 
                            iframe.style.height = '100%';
                        }
                    });
                }
                
            } catch (error) {
                console.error(`[MultiStream] Failed to load stream ${index}:`, error);
                
                // Hide loading indicator
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
                
                // Show error in stream container
                const embedContainer = document.getElementById(`stream-${index}`);
                if (embedContainer) {
                    const errorMessage = error.message || 'Unknown error';
                    embedContainer.innerHTML = `
                        <div class="flex items-center justify-center h-full bg-gray-900 text-gray-300">
                            <div class="text-center p-4">
                                <div class="text-red-400 mb-2 font-semibold">Failed to load stream</div>
                                <div class="text-gray-400 mb-3 text-sm">${errorMessage}</div>
                                <a href="https://twitch.tv/${canonicalTwitchUsername}" target="_blank" class="inline-block bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded transition-colors">
                                    Watch on Twitch
                                </a>
                            </div>
                        </div>
                    `;
                }
            }
        };

        // Simple drag-resize for each panel
        function makePanelResizable(panel, index) {
            const handle = panel.querySelector('.resize-handle');
            if (!handle) return;
            // Ensure panel is positioned/visible for pointer events
            panel.style.position = panel.style.position || 'relative';
            panel.style.cursor = 'default';
            let isResizing = false;
            let startX = 0, startY = 0, startW = 0, startH = 0;
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = panel.getBoundingClientRect();
                startW = rect.width;
                startH = rect.height;
                document.body.style.userSelect = 'none';
                // Lock flex-basis so width changes take effect
                panel.style.flex = `0 0 ${rect.width}px`;
                panel.setAttribute('data-resizing', '1');
            });
            window.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                let newW = Math.max(320, startW + dx);
                panel.style.width = newW + 'px';
                panel.style.flex = `0 0 ${newW}px`;
                panel.style.flexBasis = newW + 'px';
                // Height derives from aspect-ratio; no manual height when locked
                // Force Twitch iframe to fill the new size
                const embedHost = panel.querySelector(`#stream-${index}`) || panel.querySelector('iframe');
                if (embedHost) {
                    embedHost.style.width = '100%';
                    embedHost.style.height = '100%';
                }
            });
            window.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                document.body.style.userSelect = '';
                panel.removeAttribute('data-resizing');
            });
        }
        
        const openInNewTab = (streamer) => {
            const dropdown = document.querySelector(`option[value="${streamer}"]`);
            const displayName = dropdown ? dropdown.dataset.playerName || streamer : streamer;
            const canonicalTwitchUsername = getCanonicalTwitchUsername(streamer, displayName);
            const encodedStreamer = encodeURIComponent(canonicalTwitchUsername);
            window.open(`https://twitch.tv/${encodedStreamer}`, '_blank');
        };
        
        const openInPictureInPicture = (streamer) => {
            const dropdown = document.querySelector(`option[value="${streamer}"]`);
            const displayName = dropdown ? dropdown.dataset.playerName || streamer : streamer;
            const canonicalTwitchUsername = getCanonicalTwitchUsername(streamer, displayName);
            const encodedStreamer = encodeURIComponent(canonicalTwitchUsername);
            const pipWindow = window.open(`https://twitch.tv/${encodedStreamer}`, 'pip', 'width=400,height=300,scrollbars=no,resizable=yes');
            if (pipWindow) {
                pipWindow.focus();
            }
        };
        
        // Close modal when clicking outside
        window.onclick = (event) => {
            if (event.target == analysisModal) hideModal();
            if (event.target == overrideModal) hideOverrideModal();
            // modal close handlers removed (multistream is inline now)
            // Handle Supabase magic-link callback in hash fragment
            if (location.hash.includes('access_token') && window.supabase && window.__supabaseConfig?.url) {
                try { new URLSearchParams(location.hash.substring(1)); } catch { /* ignore */ }
            }
        };

        // Twitch OAuth Login System
        let currentUser = null;
        
        const initTwitchLogin = () => {
            const loginButton = document.getElementById('twitchLoginButton');
            const loginStatus = document.getElementById('loginStatus');
            
            // Check if elements exist before proceeding
            if (!loginButton || !loginStatus) {
                console.warn('Twitch login elements not found, skipping login initialization');
                return;
            }
            
            // Check if user is already logged in
            checkTwitchLoginStatus();
            
            // Add click handler
            loginButton.addEventListener('click', async () => {
                if (currentUser) {
                    // User is logged in, show logout option
                    if (confirm(`Logged in as ${currentUser.display_name}. Do you want to logout?`)) {
                        logout();
                    }
                } else {
                    // User not logged in, start OAuth flow
                    await startTwitchLogin();
                }
            });
        };
        
        const checkTwitchLoginStatus = async () => {
            try {
                // Check if there's a stored user token
                const storedUser = localStorage.getItem('twitchUser');
                if (storedUser) {
                    currentUser = JSON.parse(storedUser);
                    
                    // Verify the token is still valid with the server
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/session/check?username=${encodeURIComponent(currentUser.username)}`);
                        const data = await response.json();
                        
                        if (data.success && data.authorized) {
                            updateLoginUI();
                            return;
                        } else {
                            // Token is expired or invalid, clear it
                            localStorage.removeItem('twitchUser');
                            currentUser = null;
                        }
                    } catch (error) {
                        console.log('Could not verify token, using cached user data');
                        updateLoginUI();
                        return;
                    }
                }
                
                // No valid user found
                updateLoginUI();
            } catch (error) {
                console.error('Error checking login status:', error);
            }
        };
        
        const startTwitchLogin = async () => {
            try {
                // Use the proper API endpoint for OAuth initiation
                const response = await fetch(`${API_BASE_URL}/api/session/start?current_url=${encodeURIComponent(window.location.href)}`);
                const data = await response.json();
                
                if (data.success) {
                    // Open OAuth in popup
                    const popup = window.open(
                        data.oauth_url,
                        'twitchOAuth',
                        'width=600,height=700,scrollbars=yes,resizable=yes'
                    );
                    
                    // Listen for popup completion
                    const checkClosed = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkClosed);
                            // Check login status after popup closes
                            setTimeout(() => {
                                checkTwitchLoginStatus();
                            }, 1000);
                        }
                    }, 1000);
                    
                    // Listen for message from OAuth callback
                    window.addEventListener('message', (event) => {
                        if (event.data.type === 'twitch_oauth_success') {
                            currentUser = {
                                username: event.data.username,
                                display_name: event.data.display_name
                            };
                            localStorage.setItem('twitchUser', JSON.stringify(currentUser));
                            updateLoginUI();
                            popup.close();
                            clearInterval(checkClosed);
                        }
                    });
                } else {
                    console.error('Failed to get OAuth URL:', data.error);
                    alert('Failed to start login process. Please try again.');
                }
            } catch (error) {
                console.error('Error starting OAuth:', error);
                alert('Failed to start Twitch login. Please try again.');
            }
        };
        
        const logout = () => {
            currentUser = null;
            localStorage.removeItem('twitchUser');
            updateLoginUI();
            showNotification('Logged out of Twitch', 'blue', false);
        };
        
        const updateLoginUI = () => {
            const loginStatus = document.getElementById('loginStatus');
            const loginButton = document.getElementById('twitchLoginButton');
            
            // Check if elements exist before updating
            if (!loginStatus || !loginButton) {
                console.warn('Login UI elements not found, skipping UI update');
                return;
            }
            
            if (currentUser) {
                loginStatus.textContent = `${currentUser.display_name}`;
                loginButton.className = 'bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg shadow-lg cursor-pointer transition-colors duration-200 flex items-center space-x-2';
                loginButton.title = 'Click to logout';
            } else {
                loginStatus.textContent = 'Login for Clips';
                loginButton.className = 'bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg shadow-lg cursor-pointer transition-colors duration-200 flex items-center space-x-2';
                loginButton.title = 'Login with Twitch to create clips';
            }
        };
        
        // Handle window resize to ensure streams maintain proper sizing
        window.addEventListener('resize', () => {
            // Force Twitch embeds to recalculate their size
            const streamElements = document.querySelectorAll('.twitch-embed-container');
            streamElements.forEach(element => {
                const iframe = element.querySelector('iframe');
                if (iframe) {
                    // Trigger a resize event on the iframe
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                }
            });
        });

        // Get canonical Twitch username for multistream loading
        const getCanonicalTwitchUsername = (streamer, playerName) => {
            // Simply return the streamer username - no hardcoded mappings
            return streamer;
        };

        // Tab switching function for multistream
        const switchStreamTab = (index, tabType) => {
            // Update tab buttons
            const streamTab = document.getElementById(`tab-stream-${index}`);
            const clipsTab = document.getElementById(`tab-clips-${index}`);
            const streamContent = document.getElementById(`stream-content-${index}`);
            const clipsContent = document.getElementById(`clips-content-${index}`);

            if (tabType === 'stream') {
                // Activate stream tab
                streamTab.classList.add('text-white', 'border-purple-500');
                streamTab.classList.remove('text-gray-300', 'border-transparent');
                clipsTab.classList.add('text-gray-300', 'border-transparent');
                clipsTab.classList.remove('text-white', 'border-purple-500');

                // Show stream content, hide clips content
                streamContent.classList.remove('hidden');
                clipsContent.classList.add('hidden');
            } else {
                // Activate clips tab
                clipsTab.classList.add('text-white', 'border-purple-500');
                clipsTab.classList.remove('text-gray-300', 'border-transparent');
                streamTab.classList.add('text-gray-300', 'border-transparent');
                streamTab.classList.remove('text-white', 'border-purple-500');

                // Show clips content, hide stream content
                clipsContent.classList.remove('hidden');
                streamContent.classList.add('hidden');

                // Load clips if not already loaded
                loadStreamClips(index);
            }
        };

        // Load clips for a specific stream
        const loadStreamClips = async (index) => {
            const clipsTab = document.getElementById(`tab-clips-${index}`);
            const streamer = clipsTab.dataset.streamer;
            const clipsContainer = document.getElementById(`clips-container-${index}`);
            const clipsLoading = document.getElementById(`clips-loading-${index}`);

            // If already loaded, skip
            if (clipsContainer.dataset.loaded === 'true') {
                return;
            }

            console.log(`Loading clips for ${streamer}`);
            
            // Get player data to check if live
            const playerData = allPlayers.find(player => 
                player.stream?.twitchUser === streamer || 
                (player.twitch_link && player.twitch_link.includes(streamer))
            );
            // Check if player is live (includes IN-MATCH status)
            const isLive = playerData && (
                playerData.twitch_live?.is_live === true ||
                String(playerData.status || '').toLowerCase().includes('live') ||
                String(playerData.status || '').toLowerCase().includes('match')
            );
            const displayName = clipsTab.closest('.stream-player')?.querySelector('.text-lg.font-bold')?.textContent || streamer;

            try {
                clipsLoading.classList.remove('hidden');
                clipsContainer.classList.add('hidden');
                
                // Add Twitch live-clip button at the top if streamer is live
                // Avoid duplicating the Live Clip button inside the Clips tab.
                // We keep the quick action button in the header row only.
                const clipCreateButton = '';

                // Try Twitch API clips first regardless; fall back to rewind if none
                    console.log('Fetching Twitch API clips...');
                    const response = await fetch(`/api/stream-clips/${streamer}`);
                    const data = await response.json();

                if (data.success && data.data.recent_clips && data.data.recent_clips.length > 0) {
                        displayTwitchClips(index, data.data.recent_clips, clipCreateButton);
                        clipsContainer.dataset.loaded = 'true';
                        return;
                }

                // Fallback to rewind/HLS clipping
                console.log('Using rewind/HLS clipping fallback...');
                await setupRewindClipping(index, streamer, clipCreateButton);
                clipsContainer.dataset.loaded = 'true';

            } catch (error) {
                console.error('Error loading clips:', error);
                clipsContainer.innerHTML = `
                    <div class="text-center text-gray-400">
                        <div class="mb-2"> Error loading clips</div>
                        <div class="text-sm">${error.message}</div>
                    </div>
                `;
            } finally {
                clipsLoading.classList.add('hidden');
                clipsContainer.classList.remove('hidden');
            }
        };

        // Display Twitch API clips
        const displayTwitchClips = (index, clips, clipCreateButton = '') => {
            const clipsContainer = document.getElementById(`clips-container-${index}`);
            
            clipsContainer.innerHTML = `
                ${clipCreateButton}
                <div class="mb-3">
                    <h4 class="text-white font-semibold mb-2"> Recent Twitch Clips</h4>
                    <div class="grid gap-2 max-h-64 overflow-y-auto">
                        ${clips.map(clip => `
                            <div class="bg-gray-800 rounded p-3 hover:bg-gray-700 transition-colors cursor-pointer" onclick="window.open('${clip.url}', '_blank')">
                                <div class="flex items-center gap-3">
                                    <img src="${clip.thumbnail_url}" alt="${clip.title}" class="w-16 h-10 object-cover rounded">
                                    <div class="flex-1 min-w-0">
                                        <div class="text-white text-sm font-medium truncate">${clip.title}</div>
                                        <div class="text-gray-400 text-xs">
                                            ${clip.view_count.toLocaleString()} views  ${clip.duration}s
                                        </div>
                                        <div class="text-gray-500 text-xs">
                                            ${new Date(clip.created_at).toLocaleDateString()}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        };

        // Setup rewind/HLS clipping
        const setupRewindClipping = async (index, streamer, clipCreateButton = '') => {
            const clipsContainer = document.getElementById(`clips-container-${index}`);
            
            try {
                // First check if stream is live and get M3U8
                const streamResponse = await fetch(`/api/stream-live-stream/${streamer}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const streamData = await streamResponse.json();
                
                if (!streamData.success) {
                    throw new Error(streamData.error || 'Stream not available');
                }

                // Check buffer status
                const bufferResponse = await fetch(`/api/stream-buffer-status/${streamer}`);
                const bufferData = await bufferResponse.json();

                clipsContainer.innerHTML = `
                    ${clipCreateButton}
                    <div class="space-y-4">
                        <div class="mb-3">
                            <h4 class="text-white font-semibold mb-1"> Rewind Clip (Fallback)</h4>
                            <div id="buffer-status-${index}" class="text-sm text-gray-400 mb-1">
                                Buffer: ${bufferData.success ? Math.floor(bufferData.buffer_duration) : 0}s available
                            </div>
                            <div id="rewind-tip-${index}" class="text-xs text-gray-500">Auto-buffering clips unlock once buffer > 5s.</div>
                        </div>
                        
                        <div class="bg-gray-800 rounded p-4">
                            <h5 class="text-white text-sm font-medium mb-3">Create Rewind Clip</h5>
                            <div class="grid grid-cols-2 gap-3 mb-3">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Start (seconds ago)</label>
                                    <input type="number" id="clip-start-${index}" value="20" min="1" max="300" 
                                           class="w-full px-2 py-1 bg-gray-700 text-white text-sm rounded">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Duration (seconds)</label>
                                    <input type="number" id="clip-duration-${index}" value="15" min="5" max="60" 
                                           class="w-full px-2 py-1 bg-gray-700 text-white text-sm rounded">
                                </div>
                            </div>
                            <button id="rewind-create-${index}" onclick="createRewindClip(${index}, '${streamer}')" disabled 
                                    class="w-full bg-purple-600 disabled:opacity-50 hover:bg-purple-700 text-white py-2 px-4 rounded text-sm transition-colors">
                                 Create Rewind Clip
                            </button>
                        </div>
                        
                        <div id="created-clips-${index}" class="space-y-2">
                            <!-- Created clips will appear here -->
                        </div>
                    </div>
                `;

                // Poll buffer status until ready, then enable rewind button
                const pollUntilReady = async () => {
                    try {
                        const r = await fetch(`/api/stream-buffer-status/${streamer}`);
                        const d = await r.json();
                        const secs = d && d.success ? Math.floor(d.buffer_duration || 0) : 0;
                        const statusEl = document.getElementById(`buffer-status-${index}`);
                        if (statusEl) statusEl.textContent = `Buffer: ${secs}s available`;
                        if (secs >= 5) {
                            const btn = document.getElementById(`rewind-create-${index}`);
                            if (btn) btn.disabled = false;
                            const tip = document.getElementById(`rewind-tip-${index}`);
                            if (tip) tip.textContent = 'Ready. Pick Start  buffer (e.g., 1530s).';
                            return;
                        }
                        setTimeout(pollUntilReady, 2000);
                    } catch (e) {
                        setTimeout(pollUntilReady, 3000);
                    }
                };
                pollUntilReady();

            } catch (error) {
                console.error('Error setting up rewind clipping:', error);
                throw error;
            }
        };

        // Create live clip with OAuth support
        const createLiveClip = async (username, displayName) => {
            try {
                // Check if user is logged in first
                if (!currentUser) {
                    const shouldLogin = confirm(`You need to login with Twitch to create clips.\n\nWould you like to login now?`);
                    if (shouldLogin) {
                        await startTwitchLogin();
                        return; // Wait for login completion
                    } else {
                        return; // User declined to login
                    }
                }
                
                // Show initial notification
                const notification = showNotification(`Creating clip for ${displayName}...`, 'orange', true);
                
                // Try to create clip via API first (use localhost for OAuth-enabled endpoints)
                const response = await fetch(`${API_BASE_URL}/api/stream-clips/create/${username}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                // Remove initial notification
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                
                if (data.success) {
                    // Success! Show clip created notification
                    const successDiv = document.createElement('div');
                    successDiv.innerHTML = `
                        <div class="flex items-center justify-between gap-3">
                            <span> Clip created for ${displayName}!</span>
                            <div class="flex gap-2">
                                <button onclick="window.open('${data.data.url}', '_blank')" 
                                        class="bg-green-700 hover:bg-green-800 px-3 py-1 rounded text-xs">
                                    Watch
                                </button>
                                <button onclick="window.open('${data.data.edit_url}', '_blank')" 
                                        class="bg-blue-700 hover:bg-blue-800 px-3 py-1 rounded text-xs">
                                    Edit
                                </button>
                            </div>
                        </div>
                    `;
                    showNotification(successDiv.innerHTML, 'green', false, 10000);
                    
                } else if (data.error_type === 'auth_required' || data.error_type === 'insufficient_scope') {
                    // Need OAuth authorization
                    const authDiv = document.createElement('div');
                    authDiv.innerHTML = `
                        <div class="flex items-center justify-between gap-3">
                            <span> Authorization needed for automatic clipping</span>
                            <div class="flex gap-2">
                                <button onclick="authorizeClipCreation()" 
                                        class="bg-purple-700 hover:bg-purple-800 px-3 py-1 rounded text-xs">
                                    Authorize
                                </button>
                                <button onclick="window.open('https://www.twitch.tv/${username}', '_blank')" 
                                        class="bg-orange-700 hover:bg-orange-800 px-3 py-1 rounded text-xs">
                                    Manual
                                </button>
                            </div>
                        </div>
                    `;
                    showNotification(authDiv.innerHTML, 'purple', false, 8000);
                    
                } else {
                    // Other error - fall back to manual clipping
                    console.error('Clip creation error:', data.error);
                    const fallbackDiv = document.createElement('div');
                    fallbackDiv.innerHTML = `
                        <div class="flex items-center justify-between gap-3">
                            <span>Opening ${displayName}'s stream for manual clipping</span>
                            <button onclick="window.open('https://www.twitch.tv/${username}', '_blank')" 
                                    class="bg-orange-700 hover:bg-orange-800 px-3 py-1 rounded text-xs">
                                    Open Stream
                            </button>
                        </div>
                    `;
                    showNotification(fallbackDiv.innerHTML, 'orange', false, 5000);
                    window.open(`https://www.twitch.tv/${username}`, '_blank');
                }
                
            } catch (error) {
                console.error('Error with clip creation:', error);
                showNotification(` Error: ${error.message}`, 'red', false, 5000);
            }
        };

        // Show notification helper
        const showNotification = (content, color = 'blue', spinner = false, duration = 3000) => {
            const colorClasses = {
                blue: 'bg-blue-600',
                green: 'bg-green-600', 
                orange: 'bg-orange-600',
                red: 'bg-red-600',
                purple: 'bg-purple-600'
            };
            
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 ${colorClasses[color]} text-white px-6 py-3 rounded-lg shadow-lg z-50 max-w-md`;
            
            const spinnerHtml = spinner ? '<div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>' : '';
            
            notification.innerHTML = `
                <div class="flex items-center">
                    ${spinnerHtml}
                    <div>${content}</div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            if (duration > 0) {
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, duration);
            }
            
            return notification;
        };

        // Authorize clip creation OAuth flow
        const authorizeClipCreation = async () => {
            try {
                const script = document.createElement('script');
                script.src = '/assets/login.js';
                script.onload = () => {
                    if (window.loginData && window.loginData.success) {
                        // Open OAuth in popup
                        const popup = window.open(
                            window.loginData.oauth_url, 
                            'twitch_oauth',
                            'width=600,height=700,scrollbars=yes,resizable=yes'
                        );
                        
                        // Listen for OAuth completion
                        const handleMessage = (event) => {
                            if (event.data.type === 'twitch_oauth_success') {
                                showNotification(` Authorized as ${event.data.display_name}! You can now create clips automatically.`, 'green', false, 5000);
                                window.removeEventListener('message', handleMessage);
                                popup.close();
                            }
                        };
                        
                        window.addEventListener('message', handleMessage);
                    } else {
                        showNotification(' Failed to initiate authorization', 'red');
                    }
                };
                document.head.appendChild(script);
            } catch (error) {
                showNotification(` Authorization error: ${error.message}`, 'red');
            }
        };

        // Create rewind clip
        const createRewindClip = async (index, streamer) => {
            const startInput = document.getElementById(`clip-start-${index}`);
            const durationInput = document.getElementById(`clip-duration-${index}`);
            const createdClipsDiv = document.getElementById(`created-clips-${index}`);
            
            const startSeconds = parseInt(startInput.value);
            const duration = parseInt(durationInput.value);

            try {
                const response = await fetch(`/api/stream-create-clip/${streamer}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start_seconds: startSeconds,
                        duration: duration
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Add created clip to the list
                    const clipDiv = document.createElement('div');
                    clipDiv.className = 'bg-gray-800 rounded p-3';
                    clipDiv.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="text-white text-sm font-medium">Clip Created!</div>
                                <div class="text-gray-400 text-xs">
                                    ${data.actual_duration}s  ${Math.round(data.file_size / 1024)}KB
                                </div>
                            </div>
                            <a href="${data.clip_url}" download 
                               class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs transition-colors">
                                Download
                            </a>
                        </div>
                    `;
                    createdClipsDiv.appendChild(clipDiv);
                } else {
                    alert('Error creating clip: ' + data.error);
                }

            } catch (error) {
                console.error('Error creating clip:', error);
                alert('Error creating clip: ' + error.message);
            }
        };

        // 1. Automatically load streams on dropdown change
        ['streamer1', 'streamer2', 'streamer3'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                loadMultiStreams();
            });
        });
        // (pseudo-code, actual code must be inserted in the streamDiv.innerHTML template)
        // if (playerData?.vods_enabled && playerData?.recent_videos?.length > 0) {
        //   add a VOD button linking to playerData.recent_videos[0].url
        // }
        // if (playerData?.hasClips && playerData?.recentClips?.length > 0) {
        //   add a Clips button linking to playerData.recentClips[0].url
        // }
        
        // Initialize Twitch Login System
        initTwitchLogin();
        
        // Enhanced Features System
        class EnhancedFeatures {
            constructor() {
                this.currentUserId = null;
                this.userPreferences = {};
                this.notificationPermission = false;
                this.streamPreviewElement = null;
                this.refreshIntervalId = null;
                this.countdownIntervalId = null;
                this.countdownSeconds = 60;
                this.init();
            }

            async init() {
                console.log('Initializing enhanced features...');
                
                // Initialize user session (mock for now - you'll need proper auth)
                this.currentUserId = 1; // Mock user ID
                
                // Load user preferences
                await this.loadUserPreferences();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize notifications
                this.initializeNotifications();
                
                // Setup keyboard shortcuts
                this.setupKeyboardShortcuts();
                
                // Initialize stream preview
                this.initStreamPreview();
                
                // Apply theme
                this.applyTheme();
                
                console.log('Enhanced features initialized successfully');
            }

            async loadUserPreferences() {
                if (!this.currentUserId) return;
                
                try {
                    const response = await fetch(`/api/user/${this.currentUserId}/preferences`);
                    if (response.ok) {
                        const data = await response.json();
                        this.userPreferences = data.data || {};
                        this.updateUIFromPreferences();
                    }
                } catch (error) {
                    console.error('Failed to load user preferences:', error);
                }
            }

            updateUIFromPreferences() {
                const prefs = this.userPreferences;
                
                // Update settings modal
                if (document.getElementById('darkModeToggle')) {
                    document.getElementById('darkModeToggle').checked = prefs.theme !== 'light';
                }
                if (document.getElementById('autoRefreshToggle')) {
                    document.getElementById('autoRefreshToggle').checked = prefs.auto_refresh_enabled !== false;
                }
                if (document.getElementById('refreshInterval')) {
                    document.getElementById('refreshInterval').value = prefs.auto_refresh_interval || 60;
                    document.getElementById('refreshIntervalValue').textContent = `${prefs.auto_refresh_interval || 60}s`;
                }
                if (document.getElementById('notificationsToggle')) {
                    document.getElementById('notificationsToggle').checked = prefs.notifications_enabled === true;
                }
                
                // Start auto-refresh if enabled
                if (prefs.auto_refresh_enabled !== false) {
                    this.startAutoRefresh();
                } else {
                    this.stopAutoRefresh();
                }
            }

            async saveUserPreferences() {
                if (!this.currentUserId) return;
                
                try {
                    const response = await fetch(`/api/user/${this.currentUserId}/preferences`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(this.userPreferences)
                    });
                    
                    if (response.ok) {
                        this.showToast('Settings saved successfully!', 'success');
                    } else {
                        throw new Error('Failed to save settings');
                    }
                } catch (error) {
                    console.error('Failed to save preferences:', error);
                    this.showToast('Failed to save settings', 'error');
                }
            }

            setupEventListeners() {
                // Settings modal controls
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    darkModeToggle.addEventListener('change', (e) => {
                        this.userPreferences.theme = e.target.checked ? 'dark' : 'light';
                        this.applyTheme();
                        this.trackAnalyticsEvent('settings', 'theme_change', this.userPreferences.theme);
                    });
                }

                const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                if (autoRefreshToggle) {
                    autoRefreshToggle.addEventListener('change', (e) => {
                        this.userPreferences.auto_refresh_enabled = e.target.checked;
                        
                        if (e.target.checked) {
                            this.startAutoRefresh();
                        } else {
                            this.stopAutoRefresh();
                        }
                        
                        this.trackAnalyticsEvent('settings', 'auto_refresh_toggle', e.target.checked.toString());
                    });
                }

                const refreshInterval = document.getElementById('refreshInterval');
                if (refreshInterval) {
                    refreshInterval.addEventListener('input', (e) => {
                        this.userPreferences.auto_refresh_interval = parseInt(e.target.value);
                        document.getElementById('refreshIntervalValue').textContent = `${e.target.value}s`;
                        
                        // Restart timer with new interval if auto-refresh is enabled
                        if (this.userPreferences.auto_refresh_enabled) {
                            this.startAutoRefresh();
                        }
                    });
                }

                const notificationsToggle = document.getElementById('notificationsToggle');
                if (notificationsToggle) {
                    notificationsToggle.addEventListener('change', (e) => {
                        this.userPreferences.notifications_enabled = e.target.checked;
                        if (e.target.checked) {
                            this.requestNotificationPermission();
                        }
                        this.trackAnalyticsEvent('settings', 'notifications_toggle', e.target.checked.toString());
                    });
                }
            }

            applyTheme() {
                const isDark = this.userPreferences.theme !== 'light';
                document.body.classList.toggle('light-theme', !isDark);
            }

            async initializeNotifications() {
                if ('Notification' in window) {
                    if (Notification.permission === 'granted') {
                        this.notificationPermission = true;
                    } else if (Notification.permission !== 'denied') {
                        const permission = await Notification.requestPermission();
                        this.notificationPermission = permission === 'granted';
                    }
                }
            }

            async requestNotificationPermission() {
                if ('Notification' in window && Notification.permission !== 'granted') {
                    const permission = await Notification.requestPermission();
                    this.notificationPermission = permission === 'granted';
                    
                    if (this.notificationPermission) {
                        this.showToast('Notifications enabled!', 'success');
                    } else {
                        this.showToast('Notifications permission denied', 'warning');
                    }
                }
            }

            showNotification(title, options = {}) {
                if (this.notificationPermission && this.userPreferences.notifications_enabled) {
                    new Notification(title, {
                        icon: '/favicon.ico',
                        badge: '/favicon.ico',
                        ...options
                    });
                }
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Only handle shortcuts when not typing in inputs
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    switch (e.key.toLowerCase()) {
                        case ' ':
                            e.preventDefault();
                            this.toggleAllStreams();
                            break;
                        case 'f':
                            e.preventDefault();
                            this.toggleFullscreen();
                            break;
                        case 'r':
                            e.preventDefault();
                            initializeApp();
                            this.showToast('Data refreshed', 'info');
                            break;
                        case 'm':
                            e.preventDefault();
                            this.toggleGlobalMute();
                            break;
                        case '1':
                        case '2':
                        case '3':
                            e.preventDefault();
                            this.focusStream(parseInt(e.key));
                            break;
                    }
                });
            }

            initStreamPreview() {
                // Create stream preview element
                this.streamPreviewElement = document.createElement('div');
                this.streamPreviewElement.id = 'streamPreview';
                this.streamPreviewElement.className = 'fixed z-50 w-80 h-48 bg-gray-800 border border-gray-600 rounded-lg shadow-xl opacity-0 pointer-events-none transition-opacity duration-200';
                this.streamPreviewElement.innerHTML = `
                    <div class="p-3 border-b border-gray-600">
                        <div class="text-white font-semibold" id="previewTitle">Stream Preview</div>
                        <div class="text-gray-400 text-sm" id="previewSubtitle">Loading...</div>
                    </div>
                    <div class="flex-1 flex items-center justify-center">
                        <div class="text-gray-400">Hover over live streamers to preview</div>
                    </div>
                `;
                document.body.appendChild(this.streamPreviewElement);

                // Add hover listeners to live streamer rows
                this.setupStreamPreviewListeners();
            }

            setupStreamPreviewListeners() {
                // This will be called after leaderboard loads
                setTimeout(() => {
                    const liveRows = document.querySelectorAll('tr[data-live="true"]');
                    liveRows.forEach(row => {
                        const streamerName = row.querySelector('[data-streamer-name]')?.dataset.streamerName;
                        if (streamerName) {
                            row.addEventListener('mouseenter', (e) => this.showStreamPreview(e, streamerName));
                            row.addEventListener('mouseleave', () => this.hideStreamPreview());
                        }
                    });
                }, 1000);
            }

            showStreamPreview(event, streamerName) {
                const preview = this.streamPreviewElement;
                const rect = event.target.getBoundingClientRect();
                
                // Position preview
                preview.style.left = `${rect.right + 10}px`;
                preview.style.top = `${rect.top}px`;
                
                // Update content
                document.getElementById('previewTitle').textContent = streamerName;
                document.getElementById('previewSubtitle').textContent = 'Live on Twitch';
                
                // Show preview
                preview.style.opacity = '1';
                preview.style.pointerEvents = 'auto';
                
                // Track analytics
                this.trackAnalyticsEvent('ui', 'stream_preview_show', streamerName);
            }

            hideStreamPreview() {
                this.streamPreviewElement.style.opacity = '0';
                this.streamPreviewElement.style.pointerEvents = 'none';
            }

            async trackAnalyticsEvent(category, action, label = null, metadata = null) {
                try {
                    await fetch('/api/analytics/track', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            event_type: 'user_interaction',
                            event_category: category,
                            event_action: action,
                            event_label: label,
                            metadata: metadata
                        })
                    });
                } catch (error) {
                    console.error('Failed to track analytics event:', error);
                }
            }

            async addFavoriteStreamer(streamerName) {
                if (!this.currentUserId || !streamerName) return;
                
                try {
                    const response = await fetch(`/api/user/${this.currentUserId}/preferences/favorite-streamers`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ streamer: streamerName })
                    });
                    
                    if (response.ok) {
                        this.showToast(`Added ${streamerName} to favorites!`, 'success');
                        this.trackAnalyticsEvent('favorites', 'add_streamer', streamerName);
                    }
                } catch (error) {
                    console.error('Failed to add favorite streamer:', error);
                }
            }

            showToast(message, type = 'info') {
                const container = document.getElementById('toastContainer');
                if (!container) return;

                const toast = document.createElement('div');
                toast.className = `toast ${type} p-4 rounded-lg shadow-lg text-white mb-2 max-w-sm`;
                
                const colors = {
                    success: 'bg-green-600',
                    error: 'bg-red-600',
                    warning: 'bg-yellow-600',
                    info: 'bg-blue-600'
                };
                
                toast.classList.add(colors[type] || colors.info);
                toast.innerHTML = `
                    <div class="flex items-center justify-between">
                        <span>${message}</span>
                        <button onclick="this.parentElement.parentElement.remove()" class="ml-4 text-white hover:text-gray-200"></button>
                    </div>
                `;
                
                container.appendChild(toast);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.remove();
                    }
                }, 5000);
            }

            // Stream control methods
            toggleAllStreams() {
                console.log('Toggle all streams');
                this.trackAnalyticsEvent('controls', 'toggle_all_streams');
            }

            toggleFullscreen() {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
                this.trackAnalyticsEvent('controls', 'toggle_fullscreen');
            }

            toggleGlobalMute() {
                console.log('Toggle global mute');
                this.trackAnalyticsEvent('controls', 'toggle_mute');
            }

            focusStream(streamNumber) {
                console.log(`Focus stream ${streamNumber}`);
                this.trackAnalyticsEvent('controls', 'focus_stream', streamNumber.toString());
            }

            // Auto-refresh and countdown timer methods
            startAutoRefresh() {
                if (this.refreshIntervalId) {
                    clearInterval(this.refreshIntervalId);
                }
                if (this.countdownIntervalId) {
                    clearInterval(this.countdownIntervalId);
                }

                const interval = this.userPreferences.auto_refresh_interval || 60;
                this.countdownSeconds = interval;
                
                // Start countdown timer (updates every second)
                this.countdownIntervalId = setInterval(() => {
                    this.updateCountdown();
                }, 1000);

                // Start refresh timer
                this.refreshIntervalId = setInterval(() => {
                    this.refreshLeaderboard();
                }, interval * 1000);

                console.log(`Auto-refresh started: ${interval}s interval`);
                this.updateCountdownDisplay();
            }

            stopAutoRefresh() {
                if (this.refreshIntervalId) {
                    clearInterval(this.refreshIntervalId);
                    this.refreshIntervalId = null;
                }
                if (this.countdownIntervalId) {
                    clearInterval(this.countdownIntervalId);
                    this.countdownIntervalId = null;
                }
                
                const countdownElement = document.getElementById('refresh-countdown');
                if (countdownElement) {
                    countdownElement.style.display = 'none';
                }
                
                console.log('Auto-refresh stopped');
            }

            updateCountdown() {
                this.countdownSeconds--;
                
                if (this.countdownSeconds <= 0) {
                    this.countdownSeconds = this.userPreferences.auto_refresh_interval || 60;
                }
                
                this.updateCountdownDisplay();
            }

            updateCountdownDisplay() {
                const timerElement = document.getElementById('countdown-timer');
                const countdownElement = document.getElementById('refresh-countdown');
                
                if (timerElement) {
                    timerElement.textContent = `${this.countdownSeconds}s`;
                }
                
                if (countdownElement) {
                    countdownElement.style.display = this.userPreferences.auto_refresh_enabled ? 'flex' : 'none';
                }
            }

            async refreshLeaderboard() {
                try {
                    console.log('Auto-refreshing leaderboard...');
                    
                    // Reset countdown
                    this.countdownSeconds = this.userPreferences.auto_refresh_interval || 60;
                    
                    // Trigger the existing loadPlayerData function if it exists
                    if (typeof window.loadPlayerData === 'function') {
                        await window.loadPlayerData();
                    } else {
                        // Fallback: reload the page
                        window.location.reload();
                    }
                    
                    this.showToast('Data refreshed', 'info');
                    this.trackAnalyticsEvent('auto_refresh', 'data_updated');
                } catch (error) {
                    console.error('Auto-refresh error:', error);
                    this.showToast('Refresh failed', 'error');
                }
            }
        }

        // Initialize enhanced features
        const enhancedFeatures = new EnhancedFeatures();

        // Global functions for modal controls
        window.showSettingsModal = () => {
            document.getElementById('settingsModal').classList.add('show');
            enhancedFeatures.trackAnalyticsEvent('ui', 'open_settings');
        };

        window.hideSettingsModal = () => {
            document.getElementById('settingsModal').classList.remove('show');
        };

        window.saveSettings = async () => {
            await enhancedFeatures.saveUserPreferences();
            enhancedFeatures.trackAnalyticsEvent('settings', 'save_settings');
        };

        window.resetSettings = async () => {
            if (confirm('Reset all settings to defaults?')) {
                enhancedFeatures.userPreferences = {
                    theme: 'dark',
                    auto_refresh_enabled: true,
                    auto_refresh_interval: 60,
                    notifications_enabled: false,
                    favorite_streamers: []
                };
                enhancedFeatures.updateUIFromPreferences();
                enhancedFeatures.applyTheme();
                await enhancedFeatures.saveUserPreferences();
                enhancedFeatures.showToast('Settings reset to defaults', 'info');
                enhancedFeatures.trackAnalyticsEvent('settings', 'reset_settings');
            }
        };

        // Favorites Tab Functions
        async function refreshFavorites() {
            showFavoritesLoading();
            
            // Check if Supabase is initialized
            if (!supabase) {
                console.error('Supabase not initialized');
                showFavoritesError('Database connection not available. Please refresh the page.');
                return;
            }
            
            // Always re-check authentication state when loading favorites
            try {
                console.log('Checking authentication state...');
                const { data: authData, error: authError } = await supabase.auth.getUser();
                if (authError) {
                    console.error('Authentication check error:', authError);
                    showFavoritesError('Authentication error. Please sign in again.');
                    return;
                }
                
                supaUser = authData?.user || null;
                console.log('Favorites: Current user state:', supaUser ? 'authenticated' : 'not authenticated');
                
                if (!supaUser) {
                    console.log('No authenticated user found');
                    showFavoritesError();
                    return;
                }
                
                console.log('Loading favorites for user:', supaUser.id);
                
                // Get user's favorites from Supabase
                const { data: favorites, error } = await supabase
                    .from('favorites')
                    .select('twitch_username')
                    .eq('user_id', supaUser.id);
                
                if (error) {
                    console.error('Error loading favorites from Supabase:', error);
                    console.error('Error details:', {
                        code: error.code,
                        message: error.message,
                        details: error.details,
                        hint: error.hint
                    });
                    showFavoritesError(`Database error: ${error.message || 'Failed to load favorites'}`);
                    return;
                }
                
                if (!favorites || favorites.length === 0) {
                    showFavoritesEmpty();
                    return;
                }
                
                // Get Twitch data for all favorites (both online and offline)
                const usernames = favorites.map(f => f.twitch_username);
                console.log('Loading favorites for usernames:', usernames);
                
                const response = await fetch(`${API_BASE_URL}/api/twitch-users-info`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ usernames })
                });
                
                const twitchData = await response.json();
                console.log('Twitch data for favorites:', twitchData);
                
                if (twitchData.success) {
                    // Enhance streamer data with leaderboard information
                    const enhancedStreamers = await enhanceStreamersWithLeaderboardData(twitchData.data, usernames);
                    renderFavoritesList(enhancedStreamers);
                } else {
                    showFavoritesError('Failed to load streamer data');
                }
                
            } catch (error) {
                console.error('Error in refreshFavorites:', error);
                console.error('Error stack:', error.stack);
                if (error.name === 'TypeError' && error.message.includes('supabase')) {
                    showFavoritesError('Supabase connection error. Please refresh the page.');
                } else if (error.message.includes('fetch')) {
                    showFavoritesError('Network error. Please check your connection.');
                } else {
                    showFavoritesError(`Error: ${error.message || 'An error occurred while loading favorites'}`);
                }
            }
        }
        
        async function enhanceStreamersWithLeaderboardData(streamers, usernames) {
            console.log('Enhancing streamers with leaderboard data...');
            console.log('Available allPlayers:', allPlayers ? allPlayers.length : 'null');
            console.log('Streamers to enhance:', streamers.map(s => s.username));
            
            // Debug: Show some sample leaderboard players with Twitch links
            if (allPlayers && allPlayers.length > 0) {
                const playersWithTwitch = allPlayers.filter(p => p.twitch_link).slice(0, 5);
                console.log('Sample players with Twitch links:', playersWithTwitch.map(p => ({
                    name: p.player_name,
                    rank: p.rank,
                    twitch_link: p.twitch_link,
                    extracted_username: extractTwitchUsernameFromUrl(p.twitch_link)
                })));
            }
            
            // Find matching leaderboard data for each streamer
            const enhancedStreamers = streamers.map(streamer => {
                // Look for this streamer in the current leaderboard data
                let leaderboardMatch = null;
                if (allPlayers && allPlayers.length > 0) {
                    leaderboardMatch = allPlayers.find(player => {
                        // Extract username from player's twitch_link
                        if (player.twitch_link) {
                            const twitchUsername = extractTwitchUsernameFromUrl(player.twitch_link);
                            const match = twitchUsername && twitchUsername.toLowerCase() === streamer.username.toLowerCase();
                            if (match) {
                                console.log(`Found leaderboard match: ${streamer.username} -> Rank #${player.rank}`);
                            }
                            return match;
                        }
                        return false;
                    });
                }
                
                if (!leaderboardMatch) {
                    console.log(`No leaderboard match found for: ${streamer.username}`);
                }
                
                // Add leaderboard info to streamer
                return {
                    ...streamer,
                    leaderboard: leaderboardMatch ? {
                        rank: leaderboardMatch.rank,
                        rp: leaderboardMatch.rp,
                        rp_change_24h: leaderboardMatch.rp_change_24h,
                        level: leaderboardMatch.level,
                        player_name: leaderboardMatch.player_name,
                        status: leaderboardMatch.status,
                        country_code: leaderboardMatch.country_code,
                        input_device: leaderboardMatch.input_device
                    } : null
                };
            });
            
            return enhancedStreamers;
        }
        
        function extractTwitchUsernameFromUrl(url) {
            if (!url) return null;
            const match = url.match(/twitch\.tv\/([a-zA-Z0-9_]+)/i);
            return match ? match[1].toLowerCase() : null;
        }
        
        function showFavoritesLoading() {
            document.getElementById('favoritesLoading').style.display = 'block';
            document.getElementById('favoritesError').style.display = 'none';
            document.getElementById('favoritesEmpty').style.display = 'none';
            document.getElementById('favoritesList').style.display = 'none';
        }
        
        function showFavoritesError(message = 'Please sign in to view your favorite streamers.') {
            const errorEl = document.getElementById('favoritesError');
            errorEl.querySelector('p').textContent = message;
            errorEl.style.display = 'block';
            document.getElementById('favoritesLoading').style.display = 'none';
            document.getElementById('favoritesEmpty').style.display = 'none';
            document.getElementById('favoritesList').style.display = 'none';
        }
        
        function showFavoritesEmpty() {
            document.getElementById('favoritesEmpty').style.display = 'block';
            document.getElementById('favoritesLoading').style.display = 'none';
            document.getElementById('favoritesError').style.display = 'none';
            document.getElementById('favoritesList').style.display = 'none';
        }
        
        function renderFavoritesList(streamers) {
            const listEl = document.getElementById('favoritesList');
            
            let html = '';
            streamers.forEach(streamer => {
                const isLive = streamer.is_live;
                const statusColor = isLive ? 'text-emerald-400' : 'text-gray-400';
                const statusText = isLive ? 'LIVE' : 'Offline';
                const statusIcon = isLive ? 
                    '<div class="w-2 h-2 bg-emerald-500 rounded-full animate-pulse"></div>' :
                    '<div class="w-2 h-2 bg-gray-500 rounded-full"></div>';
                
                const viewerCount = isLive && streamer.viewer_count ? 
                    `<span class="text-xs text-gray-400 ml-2">${streamer.viewer_count.toLocaleString()} viewers</span>` : '';
                
                const gameText = isLive && streamer.game_name ? 
                    `<p class="text-xs text-gray-400 mt-1">Playing: ${streamer.game_name}</p>` : '';
                
                // Add leaderboard information
                const leaderboardInfo = streamer.leaderboard ? `
                    <div class="mt-2 p-2 bg-gray-800/50 rounded border-l-2 border-emerald-500">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-4">
                                <div class="text-center">
                                    <div class="text-lg font-bold text-emerald-400">#${streamer.leaderboard.rank}</div>
                                    <div class="text-xs text-gray-400">Rank</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-sm font-medium text-white">${streamer.leaderboard.rp?.toLocaleString() || 0}</div>
                                    <div class="text-xs text-gray-400">RP</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-sm font-medium ${streamer.leaderboard.rp_change_24h > 0 ? 'text-green-400' : streamer.leaderboard.rp_change_24h < 0 ? 'text-red-400' : 'text-gray-400'}">
                                        ${streamer.leaderboard.rp_change_24h > 0 ? '+' : ''}${streamer.leaderboard.rp_change_24h?.toLocaleString() || 0}
                                    </div>
                                    <div class="text-xs text-gray-400">24h</div>
                                </div>
                                ${streamer.leaderboard.level ? `
                                <div class="text-center">
                                    <div class="text-sm font-medium text-blue-400">Lvl ${streamer.leaderboard.level}</div>
                                    <div class="text-xs text-gray-400">Level</div>
                                </div>
                                ` : ''}
                            </div>
                            ${streamer.leaderboard.country_code ? `
                            <div class="flex items-center space-x-2">
                                <span class="flag-icon flag-icon-${streamer.leaderboard.country_code}" title="${streamer.leaderboard.country_code.toUpperCase()}"></span>
                                ${streamer.leaderboard.input_device === 'controller' ? '<i class="fas fa-gamepad text-gray-400" title="Controller"></i>' : ''}
                                ${streamer.leaderboard.input_device === 'kbm' ? '<i class="fas fa-mouse text-gray-400" title="Keyboard & Mouse"></i>' : ''}
                            </div>
                            ` : ''}
                        </div>
                    </div>
                ` : '<div class="mt-2 text-xs text-gray-500 italic">Not currently on leaderboard</div>';
                
                html += `
                    <div class="bg-gray-700/50 p-4 rounded-lg border border-gray-600/50 hover:border-purple-500/50 transition-all duration-200">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-3">
                                <img src="${streamer.profile_image_url || 'https://via.placeholder.com/40x40/6B7280/FFFFFF?text=?'}" 
                                     alt="${streamer.display_name}" 
                                     class="w-10 h-10 rounded-full">
                                <div class="flex-1">
                                    <h4 class="font-medium text-white">${streamer.display_name || streamer.username}</h4>
                                    <div class="flex items-center space-x-2">
                                        ${statusIcon}
                                        <span class="text-sm font-medium ${statusColor}">${statusText}</span>
                                        ${viewerCount}
                                    </div>
                                    ${gameText}
                                    ${leaderboardInfo}
                                </div>
                            </div>
                            <div class="flex items-center space-x-2">
                                ${isLive ? `
                                    <button onclick="watchStream('${streamer.username}')" 
                                            class="px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm rounded-lg transition-colors duration-200">
                                        Watch
                                    </button>
                                ` : ''}
                                <button onclick="toggleFavorite('${streamer.username}')" 
                                        class="px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm rounded-lg transition-colors duration-200" 
                                        title="Remove from favorites">
                                    Remove
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
            listEl.style.display = 'block';
            document.getElementById('favoritesLoading').style.display = 'none';
            document.getElementById('favoritesError').style.display = 'none';
            document.getElementById('favoritesEmpty').style.display = 'none';
            
            // Update favorites count
            const favoritesCountEl = document.getElementById('favoritesCount');
            if (favoritesCountEl) {
                favoritesCountEl.textContent = streamers.length;
            }
        }
        
        function watchStream(username) {
            // Open the multistream dock first
            openMultiStreamDock();
            
            // Add the streamer to the first available dropdown
            setTimeout(() => {
                const streamer1 = document.getElementById('streamer1');
                const streamer2 = document.getElementById('streamer2');
                const streamer3 = document.getElementById('streamer3');
                
                if (streamer1 && streamer1.value === '') {
                    streamer1.value = username;
                    enhancedFeatures.showToast(`Added ${username} to Stream 1`, 'success');
                } else if (streamer2 && streamer2.value === '') {
                    streamer2.value = username;
                    enhancedFeatures.showToast(`Added ${username} to Stream 2`, 'success');
                } else if (streamer3 && streamer3.value === '') {
                    streamer3.value = username;
                    enhancedFeatures.showToast(`Added ${username} to Stream 3`, 'success');
                } else {
                    // If all slots are taken, replace the first one
                    if (streamer1) {
                        streamer1.value = username;
                        enhancedFeatures.showToast(`Replaced Stream 1 with ${username}`, 'info');
                    }
                }
                
                // Automatically load the streams
                loadMultiStreams();
            }, 100); // Small delay to ensure modal is fully shown
        }
        
        // Account Management Functions
        function showChangePasswordModal() {
            document.getElementById('changePasswordModal').classList.add('show');
        }

        function hideChangePasswordModal() {
            document.getElementById('changePasswordModal').classList.remove('show');
            document.getElementById('changePasswordForm').reset();
            document.getElementById('changePasswordError').style.display = 'none';
        }

        async function signOut() {
            if (supabase && supaUser) {
                try {
                    await supabase.auth.signOut();
                    supaUser = null;
                    updateAccountDisplay();
                    enhancedFeatures.showToast('Signed out successfully', 'success');
                } catch (error) {
                    console.error('Sign out error:', error);
                    enhancedFeatures.showToast('Error signing out', 'error');
                }
            }
        }

        function updateAccountDisplay() {
            const statusText = document.getElementById('accountStatusText');
            const signInBtn = document.getElementById('signInBtn');
            const signOutBtn = document.getElementById('signOutBtn');
            const changePasswordBtn = document.getElementById('changePasswordBtn');
            const accountCreated = document.getElementById('accountCreated');

            if (supaUser) {
                if (statusText) statusText.textContent = supaUser.email || 'Signed in';
                if (signInBtn) signInBtn.style.display = 'none';
                if (signOutBtn) signOutBtn.style.display = 'block';
                if (changePasswordBtn) changePasswordBtn.style.display = 'block';
                if (accountCreated && supaUser.created_at) {
                    accountCreated.textContent = new Date(supaUser.created_at).toLocaleDateString();
                }
            } else {
                if (statusText) statusText.textContent = 'Not signed in';
                if (signInBtn) signInBtn.style.display = 'block';
                if (signOutBtn) signOutBtn.style.display = 'none';
                if (changePasswordBtn) changePasswordBtn.style.display = 'none';
                if (accountCreated) accountCreated.textContent = '-';
            }
        }

        // Handle change password form submission
        document.addEventListener('DOMContentLoaded', () => {
            const changePasswordForm = document.getElementById('changePasswordForm');
            if (changePasswordForm) {
                changePasswordForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const currentPassword = document.getElementById('currentPassword').value;
                    const newPassword = document.getElementById('newPassword').value;
                    const confirmPassword = document.getElementById('confirmPassword').value;
                    const errorDiv = document.getElementById('changePasswordError');

                    // Validate passwords match
                    if (newPassword !== confirmPassword) {
                        errorDiv.textContent = 'New passwords do not match';
                        errorDiv.style.display = 'block';
                        return;
                    }

                    try {
                        // Use Supabase to update password
                        const { error } = await supabase.auth.updateUser({
                            password: newPassword
                        });

                        if (error) {
                            throw error;
                        }

                        enhancedFeatures.showToast('Password updated successfully', 'success');
                        hideChangePasswordModal();
                    } catch (error) {
                        console.error('Password change error:', error);
                        errorDiv.textContent = error.message || 'Error updating password';
                        errorDiv.style.display = 'block';
                    }
                });
            }
        });

        // Update the showTab function to refresh account data and favorites
        const originalShowTab = showTab;
        window.showTab = (tabId) => {
            originalShowTab(tabId);
            
            if (tabId === 'accountTab') {
                updateAccountDisplay();
                refreshFavorites();
                // Scroll to top for account tab
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else if (tabId === 'multiStreamTab') {
                openMultiStreamDock();
                // For Multi-Stream, scroll to top immediately to show it at the top
                window.scrollTo({ top: 0, behavior: 'instant' });
            } else {
                // For other tabs, scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        };

        window.toggleMultiStreamFullscreen = () => {
            const modal = document.getElementById('multiStreamModal');
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                modal.requestFullscreen();
            }
        };

        // Enhanced CSS Styles
        const enhancedStyles = document.createElement('style');
        enhancedStyles.textContent = `
            .toast {
                background: linear-gradient(135deg, #1f2937, #374151);
                border-left: 4px solid #10b981;
                border-radius: 0.75rem;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
                transform: translateX(100%);
                transition: transform 0.3s ease-in-out, opacity 0.3s ease;
                opacity: 0;
                animation: slideIn 0.3s ease-out forwards;
            }
            
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            .favorite-btn.favorited {
                color: #ef4444 !important;
            }
            
            .favorite-btn.favorited svg {
                fill: currentColor;
            }
            
            body.light-theme {
                background-color: #f9fafb;
                color: #1f2937;
                transition: background-color 0.3s ease, color 0.3s ease;
            }
            
            body.light-theme .bg-gray-800 {
                background-color: #ffffff !important;
                border-color: #e5e7eb !important;
            }
            
            body.light-theme .bg-gray-700 {
                background-color: #f3f4f6 !important;
                border-color: #d1d5db !important;
            }
            
            body.light-theme .text-white {
                color: #1f2937 !important;
            }
            
            body.light-theme .text-gray-300 {
                color: #4b5563 !important;
            }
            
            body.light-theme .text-gray-400 {
                color: #6b7280 !important;
            }
            
            body.light-theme .border-gray-600 {
                border-color: #d1d5db !important;
            }
            
            body.light-theme .border-gray-700 {
                border-color: #e5e7eb !important;
            }
            
            #streamPreview {
                backdrop-filter: blur(10px);
                background: rgba(31, 41, 55, 0.95);
            }
            
            body.light-theme #streamPreview {
                background: rgba(255, 255, 255, 0.95);
                border-color: #d1d5db;
            }
        `;
        document.head.appendChild(enhancedStyles);
    </script>
</body>
</html>


<!-- Settings Panel Modal -->
<div id="settingsModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold text-white">Settings</h2>
            <span class="close-button" onclick="hideSettingsModal()">&times;</span>
        </div>
        
        <!-- Auto-Refresh Settings -->
        <div class="mb-6 p-4 bg-gray-700 rounded-lg">
            <h3 class="text-lg font-semibold text-white mb-4">Auto-Refresh</h3>
            <div class="flex items-center justify-between mb-4">
                <span class="text-gray-300">Enable Auto-Refresh</span>
                <div class="relative inline-block w-10 mr-2 align-middle select-none">
                    <input type="checkbox" id="autoRefreshToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 border-gray-600 appearance-none cursor-pointer transition-transform duration-200 ease-in" checked/>
                    <label for="autoRefreshToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                </div>
            </div>
            <div class="flex items-center space-x-4">
                <label class="text-sm text-gray-300">Interval (seconds):</label>
                <input type="range" id="refreshInterval" class="flex-1 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer" min="30" max="300" value="60" step="30">
                <span id="refreshIntervalValue" class="text-white text-sm min-w-[60px]">60s</span>
            </div>
        </div>
        
        <!-- Theme Settings -->
        <div class="mb-6 p-4 bg-gray-700 rounded-lg">
            <h3 class="text-lg font-semibold text-white mb-4">Theme</h3>
            <div class="flex items-center justify-between">
                <span class="text-gray-300">Dark Mode</span>
                <div class="relative inline-block w-10 mr-2 align-middle select-none">
                    <input type="checkbox" id="darkModeToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 border-gray-600 appearance-none cursor-pointer transition-transform duration-200 ease-in" checked/>
                    <label for="darkModeToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                </div>
            </div>
        </div>
        
        <!-- Notification Settings -->
        <div class="mb-6 p-4 bg-gray-700 rounded-lg">
            <h3 class="text-lg font-semibold text-white mb-4">Notifications</h3>
            <div class="flex items-center justify-between mb-4">
                <span class="text-gray-300">Desktop Notifications</span>
                <div class="relative inline-block w-10 mr-2 align-middle select-none">
                    <input type="checkbox" id="notificationsToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 border-gray-600 appearance-none cursor-pointer transition-transform duration-200 ease-in"/>
                    <label for="notificationsToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                </div>
            </div>
            <p class="text-xs text-gray-400">Get notified when your favorite streamers go live</p>
        </div>
        
        <!-- Keyboard Shortcuts -->
        <div class="mb-6 p-4 bg-gray-700 rounded-lg">
            <h3 class="text-lg font-semibold text-white mb-4">Keyboard Shortcuts</h3>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                    <span class="text-gray-300">Pause/Play Streams:</span>
                    <kbd class="px-2 py-1 bg-gray-800 rounded text-white">Space</kbd>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-300">Fullscreen Toggle:</span>
                    <kbd class="px-2 py-1 bg-gray-800 rounded text-white">F</kbd>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-300">Refresh Data:</span>
                    <kbd class="px-2 py-1 bg-gray-800 rounded text-white">R</kbd>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-300">Mute/Unmute:</span>
                    <kbd class="px-2 py-1 bg-gray-800 rounded text-white">M</kbd>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-300">Switch Stream (1-3):</span>
                    <div class="space-x-1">
                        <kbd class="px-2 py-1 bg-gray-800 rounded text-white">1</kbd>
                        <kbd class="px-2 py-1 bg-gray-800 rounded text-white">2</kbd>
                        <kbd class="px-2 py-1 bg-gray-800 rounded text-white">3</kbd>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Reset Settings -->
        <div class="flex justify-between items-center">
            <button onclick="resetSettings()" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors">
                Reset to Defaults
            </button>
            <button onclick="saveSettings()" class="px-6 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg transition-colors">
                Save Settings
            </button>
        </div>
    </div>
</div>

<!-- Toast Notifications Container -->
<div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>